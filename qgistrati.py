# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QGIStrati
                                 A QGIS plugin
 This plugin automates stratigraphic modelling tasks for archaeologists
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-05-04
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Elisa Caron-Laviolette
        email                : elisa.laviolette@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

#################
#### IMPORTS ####
#################

import processing
import os.path
import sip
import re
import itertools
import tempfile
import uuid
import math

from qgis.core import QgsProject, QgsExpression, QgsWkbTypes, QgsApplication, QgsVectorFileWriter, QgsRasterFileWriter, QgsVectorLayer, QgsRasterLayer, QgsRasterBandStats, QgsSingleBandPseudoColorRenderer, QgsColorRampShader, QgsRasterShader, QgsField, QgsSpatialIndex, QgsFeature, QgsGeometry, QgsPointXY, QgsExpressionContextUtils, QgsPrintLayout, QgsRuleBasedRenderer, QgsLayoutItemRegistry, QgsProcessingFeedback, QgsRaster
from qgis.utils import qgsfunction

from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt, QVariant
from PyQt5.QtGui import QIcon, QStandardItem, QStandardItemModel
from PyQt5.QtWidgets import QAction, QComboBox, QTableWidgetItem, QApplication, QWhatsThis, QWidget

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .qgistrati_dockwidget import QGIStratiDockWidget, QProgressIndicator
import os.path

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

#################
### CONSTANTS ###
#################

DEBUG_MODE = True

INTERPOLATION_BSPLINE = 0
INTERPOLATION_TIN = 1
INTERPOLATION_IDW = 2

INTERPOLATIONS = {'Bspline': INTERPOLATION_BSPLINE, 'TIN': INTERPOLATION_TIN, 'IDW': INTERPOLATION_IDW}

AGGREGATE_MIN = 0
AGGREGATE_Q1 = 1
AGGREGATE_MEAN = 2
AGGREGATE_MEDIAN = 3
AGGREGATE_Q3 = 4
AGGREGATE_MAX = 5

AGGREGATES = {'min': AGGREGATE_MIN, 'q1': AGGREGATE_Q1, 'mean': AGGREGATE_Q1, 'median': AGGREGATE_MEDIAN, 'q3': AGGREGATE_Q3, 'max': AGGREGATE_MAX}

PARENT_HIGHER = 0
CHILD_HIGHER = 1

NO_FILTER_TEXT = '== PAS DE FILTRE =='
NEW_LAYOUT_TEXT = '== NOUVELLE MISE EN PAGE =='
ATLAS_RULE_NAME = 'Atlas basé sur les axes'

LABELS = {
    'None': 'Aucune'
}

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

#################
### GUI CLASS ###
#################

class QGIStrati:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'QGIStrati_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&QGIStrati')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'QGIStrati')
        self.toolbar.setObjectName(u'QGIStrati')

        #print "** INITIALIZING QGIStrati"

        self.pluginIsActive = False
        self.dockwidget = None

        # Import QGIS functions
        QgsExpression.registerFunction(layout_X)
        QgsExpression.registerFunction(layout_Y)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('QGIStrati', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/qgistrati/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'QGIStrati'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        debug_print("** CLOSING QGIStrati")

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False
        self.pluginIsOpened = False

        # disconnect changes in the layer tree
        try:
            QgsProject.instance().layersAdded.disconnect(self.initComboBoxes)
            QgsProject.instance().layersRemoved.disconnect(self.initComboBoxes)
            #QgsProject.instance().readProject.disconnect(self.initComboBoxes)
        except:
            pass

    def onOpenPlugin(self):
        """Loads necessary items here when plugin dockwidget is opened"""

        debug_print("** OPENING QGIStrati")

        # disconnects
        self.dockwidget.openingPlugin.disconnect(self.onOpenPlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = True
        self.pluginIsOpened = True

        # connect changes in the layer tree
        QgsProject.instance().layersAdded.connect(self.initComboBoxes)
        QgsProject.instance().layersRemoved.connect(self.initComboBoxes)
        #QgsProject.instance().readProject.connect(self.initComboBoxes)

        # enable push buttons
        self.setEnabledPushButtons(True)

        # initialize combo boxes
        self.initComboBoxes()

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD QGIStrati"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&QGIStrati'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

        # disconnect changes in the layer tree
        try:
            QgsProject.instance().layersAdded.disconnect(self.initComboBoxes)
            QgsProject.instance().layersRemoved.disconnect(self.initComboBoxes)
            #QgsProject.instance().readProject.disconnect(self.initComboBoxes)
        except:
            pass

    #--------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        self.init = True

        if not self.pluginIsActive:
            self.pluginIsActive = True

            self.pluginIsOpened = False

            debug_print("** STARTING QGIStrati")

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = QGIStratiDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # connect to provide loading on opening of dockwidget
            self.dockwidget.openingPlugin.connect(self.onOpenPlugin)

            # initialize dockwidget elements
            self.initVariables()
            self.initDockWidget()

            self.init = False

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

            self.onOpenPlugin()

    #--------------------------------------------------------------------------

    def setEnabledPushButtons(self, boolean):

        if type(boolean) is not bool:
            return

        self.dockwidget.dem_creation_pushButton.setEnabled(boolean)
        self.dockwidget.dem_correction_pushButton.setEnabled(boolean)
        self.dockwidget.dem_harmonization_pushButton.setEnabled(boolean)
        self.dockwidget.profile_creation_pushButton.setEnabled(boolean)
        self.dockwidget.object_projection_pushButton.setEnabled(boolean)
        self.dockwidget.link_creation_pushButton.setEnabled(boolean)
        self.dockwidget.link_projection_pushButton.setEnabled(boolean)
        self.dockwidget.axis_filtering_pushButton.setEnabled(boolean)
        self.dockwidget.atlas_configuring_pushButton.setEnabled(boolean)
        self.dockwidget.connection_lines_creation_pushButton.setEnabled(boolean)

    def setEnabledComboBoxes(self, boolean):

        if type(boolean) is not bool:
            return

        for comboBox in self.comboBoxes:
            comboBox.setEnabled(boolean)

    def setEnabledListViews(self, boolean):

        if type(boolean) is not bool:
            return

        for listView in self.listViews:
            listView.setEnabled(boolean)

    #--------------------------------------------------------------------------

    def initDockWidget(self):
        """Initializes dock widget interface"""

        """
        Initialize help button
        """

        self.dockwidget.helpButton.clicked.connect(self.toggleWhatsThisMode)

        """
        Initialize progress indicator
        """
        self.dockwidget.progress_indicator = QProgressIndicator(self.dockwidget.dockWidgetContents)
        self.dockwidget.resize(self.dockwidget.tabWidget.width(), self.dockwidget.tabWidget.height())
        self.dockwidget.progress_indicator.setVisible(False)

        """
        Initialize DEM creation interface
        """

        self.initDemCreationWidget()

        """
        Initialize DEM correction interface
        """

        self.initDemCorrectionWidget()

        """
        Initialize DEM harmonization interface
        """

        self.initDemHarmonizationWidget()

        """
        Initialize profile creation interface
        """

        self.initProfileCreationWidget()

        """
        Initialize object projection interface
        """

        self.initObjectProjectionWidget()

        """
        Initialize link creation interface
        """

        self.initLinkCreationWidget()

        """
        Initialize link projection interface
        """

        self.initLinkProjectionWidget()

        """
        Initialize axis filtering interface
        """

        self.initAxisFilteringWidget()

        """
        Initialize atlas configuring interface
        """

        self.initAtlasConfiguringWidget()

        """
        Initialize connection lines creation interface
        """

        self.initConnectionLinesCreationWidget()

    #--------------------------------------------------------------------------

    def toggleWhatsThisMode(self):
        """Toggles What's This Mode"""

        if QWhatsThis.inWhatsThisMode():
            QWhatsThis.leaveWhatsThisMode()
        else:
            QWhatsThis.enterWhatsThisMode()

    #--------------------------------------------------------------------------

    def initVariables(self):
        """Initializes all variables"""

        # Initialize variables for DEM creation

        self.altitude_field = None
        self.sourceLayerNumericFields = []
        self.sourceLayerNumericFieldNames = []
        self.topo_layer = None
        self.dem_creation_aggregate_type = 0
        self.dem_creation_interpolation_method = 0
        self.dem_creation_extent_method = 0
        self.extent_layer = None
        self.dem_creation_clipping = False
        self.dem_creation_extent_coords = ''
        self.dem_creation_distance = 0
        self.dem_creation_resolution = 0.01
        self.dem_creation_filter_expression = ''

        # Initialize variables for DEM correction

        self.demList = []
        self.rules = []

        # Initialize variables for DEM harmonization

        self.demList = []
        self.dem_harmonization_gradient = None
        self.dem_harmonization_interval = 0.01
        self.dem_harmonization_contour = False
        self.dem_harmonization_hillshade = False

        # Initialize variables for profile creation

        self.axis_layer = None
        self.demList = []
        self.intersectLayerFields = []
        self.intersectLayerFieldNames = []
        self.profile_creation_intersect_id_field = ''
        self.intersect_layer = None
        self.profile_creation_intersect_filter_expression = ''
        self.profile_creation_grid = False
        self.extremities = False

        # Initialize variables for object projection

        self.objectLayerNumericFields = []
        self.objectLayerNumericFieldNames = []
        self.altitude_field = None
        self.objects_layer = None
        self.axis_layer = None
        self.object_projection_grid = False

        # Initialize variables for link creation

        self.link_creation_fieldList = []
        self.object_id_field_list = []
        self.link_creation_links_layer = None
        self.objectLayerFields = []
        self.objectLayerFieldNames = []
        self.objects_id_field = None
        self.objects_layer = None

        # Initialize variables for link projection

        self.link_projection_fieldList = []
        self.object_id_field_list = []
        self.link_projection_links_layer = None
        self.objectLayerFields = []
        self.objectLayerFieldNames = []
        self.objects_id_field = None
        self.objectLayerNumericFields = []
        self.objectLayerNumericFieldNames = []
        self.altitude_field = None
        self.objects_layer = None
        self.axis_layer = None

        # Initialize variables for axis filtering

        self.axis_filtering_filter = None
        self.axisLayerFields = []
        self.axisLayerFieldNames = []
        self.axis_filtering_field = None
        self.axis_layer = None
        self.filteredLayerFields = []
        self.filteredLayerFieldNames = []
        self.axis_id_field = None
        self.layerList = []

        # Initialize variables for atlas configuring

        self.layout_name = None
        self.axis_layer = None
        self.filteredLayerFields = []
        self.filteredLayerFieldNames = []
        self.axis_id_field = None
        self.layerList = []

        # Initialize variables for connection lines creation

        self.maps = []
        self.mapNames = []
        self.connection_lines_creation_layout = None

        # Clear all list views

        listViews = [self.dockwidget.dem_correction_dems_listView,
                     self.dockwidget.dem_harmonization_dems_listView,
                     self.dockwidget.profile_creation_dems_listView,
                     self.dockwidget.link_creation_links_layer_fields_listView,
                     self.dockwidget.link_projection_links_layer_fields_listView,
                     self.dockwidget.axis_filtering_layers_listView,
                     self.dockwidget.atlas_configuring_layers_listView
        ]

        for view in listViews:
            model = QStandardItemModel(view)
            view.setModel(model)

    def initComboBoxes(self):
        """Initializes all combo boxes and list views"""

        # Do nothing is plugin is not active
        if not self.pluginIsOpened:
            return

        self.init = True

        debug_print("INITIATING COMBO BOXES")  

        #QApplication.setOverrideCursor(Qt.WaitCursor)

        # List all list views and combo boxes

        self.axisLayerComboBoxes = [self.dockwidget.profile_creation_axis_layer_comboBox,
                               self.dockwidget.object_projection_axis_layer_comboBox,
                               self.dockwidget.link_projection_axis_layer_comboBox,
                               self.dockwidget.axis_filtering_axis_layer_comboBox,
                               self.dockwidget.atlas_configuring_axis_layer_comboBox
        ]

        self.objectsLayerComboBoxes = [self.dockwidget.object_projection_objects_layer_comboBox,
                                  self.dockwidget.link_creation_objects_layer_field_comboBox,
                                  self.dockwidget.link_creation_objects_layer_comboBox,
                                  self.dockwidget.link_projection_objects_layer_field_comboBox,
                                  self.dockwidget.link_projection_objects_layer_comboBox,
                                  self.dockwidget.dem_creation_topo_layer_comboBox
        ]

        self.altitudeFieldComboBoxes = [self.dockwidget.dem_creation_altitude_field_comboBox,
                                        self.dockwidget.object_projection_altitude_field_comboBox,
                                        self.dockwidget.link_projection_altitude_field_comboBox
        ]

        self.objectsIdFieldComboBoxes = [self.dockwidget.link_creation_objects_layer_field_comboBox,
                                         self.dockwidget.axis_filtering_id_field_comboBox
        ]

        self.axisIdFieldComboBoxes = [self.dockwidget.atlas_configuring_id_field_comboBox,
                                      self.dockwidget.axis_filtering_id_field_comboBox
        ]

        self.layoutComboBoxes = [self.dockwidget.atlas_configuring_layout_name_comboBox,
                                 self.dockwidget.connection_lines_creation_layout_comboBox
        ]

        self.comboBoxes = [self.dockwidget.dem_creation_altitude_field_comboBox,
                      self.dockwidget.dem_creation_topo_layer_comboBox,
                      self.dockwidget.dem_creation_aggregate_type_comboBox,
                      self.dockwidget.dem_creation_interpolation_method_comboBox,
                      self.dockwidget.dem_creation_extent_layer_comboBox,
                      self.dockwidget.profile_creation_axis_layer_comboBox,
                      self.dockwidget.profile_creation_intersect_id_field_comboBox,
                      self.dockwidget.profile_creation_intersect_layer_comboBox,
                      self.dockwidget.object_projection_altitude_field_comboBox,
                      self.dockwidget.object_projection_objects_layer_comboBox,
                      self.dockwidget.object_projection_axis_layer_comboBox,
                      self.dockwidget.link_creation_links_layer_comboBox,
                      self.dockwidget.link_creation_objects_layer_field_comboBox,
                      self.dockwidget.link_creation_objects_layer_comboBox,
                      self.dockwidget.link_projection_links_layer_comboBox,
                      self.dockwidget.link_projection_objects_layer_field_comboBox,
                      self.dockwidget.link_projection_altitude_field_comboBox,
                      self.dockwidget.link_projection_objects_layer_comboBox,
                      self.dockwidget.link_projection_axis_layer_comboBox,
                      self.dockwidget.axis_filtering_filter_comboBox,
                      self.dockwidget.axis_filtering_field_comboBox,
                      self.dockwidget.axis_filtering_axis_layer_comboBox,
                      self.dockwidget.axis_filtering_id_field_comboBox,
                      self.dockwidget.atlas_configuring_layout_name_comboBox,
                      self.dockwidget.atlas_configuring_axis_layer_comboBox,
                      self.dockwidget.atlas_configuring_id_field_comboBox,
                      self.dockwidget.connection_lines_creation_layout_comboBox
        ]

        self.demListViews = [self.dockwidget.dem_correction_dems_listView,
                             self.dockwidget.dem_harmonization_dems_listView,
                             self.dockwidget.profile_creation_dems_listView
        ]

        self.objectIdFieldListViews = [self.dockwidget.link_creation_links_layer_fields_listView,
                                       self.dockwidget.link_projection_links_layer_fields_listView
        ]

        self.vectorLayerListViews = [self.dockwidget.axis_filtering_layers_listView,
                                     self.dockwidget.atlas_configuring_layers_listView
        ]

        self.listViews = [self.dockwidget.dem_correction_dems_listView,
                     self.dockwidget.dem_harmonization_dems_listView,
                     self.dockwidget.profile_creation_dems_listView,
                     self.dockwidget.link_creation_links_layer_fields_listView,
                     self.dockwidget.link_projection_links_layer_fields_listView,
                     self.dockwidget.axis_filtering_layers_listView,
                     self.dockwidget.atlas_configuring_layers_listView
        ]

        # Disable all list views and combo boxes
        self.dockwidget.dockWidgetContents.setEnabled(False)

        main_width = self.dockwidget.dockWidgetContents.width()
        main_height = self.dockwidget.dockWidgetContents.height()

        indicator_width = self.dockwidget.progress_indicator.width()
        indicator_height = self.dockwidget.progress_indicator.height()

        self.dockwidget.progress_indicator.move(int(main_width/2 - (indicator_width/2)), int(main_height/2 - (indicator_height/2)))

        self.dockwidget.progress_indicator.setVisible(True)
        self.dockwidget.progress_indicator.startAnimation()

        # Initialize all relevant lists

        self.vectorLayers = listVectorLayers()
        self.vectorLayerNames = layerNames(self.vectorLayers)

        self.demLayers = listRasterLayers()
        self.demLayerNames = layerNames(self.demLayers)

        self.polygonAndPointLayers = listPolygonLayers() + listPointLayers()
        self.polygonAndPointLayerNames = layerNames(self.polygonAndPointLayers)

        self.polygonLayers = listPolygonLayers()
        self.polygonLayerNames = layerNames(self.polygonLayers)

        self.lineLayers = listLineLayers()
        self.lineLayerNames = layerNames(self.lineLayers)

        self.noGeomLayers = listNoGeomLayers()
        self.noGeomLayerNames = layerNames(self.noGeomLayers)

        self.layouts = listLayouts()
        self.layoutNames = layoutNames(self.layouts)

        # Clear all combo boxes

        for box in self.comboBoxes:
            box.clear()

        # Populate combo boxes with relevant list

        populateComboBox(self.dockwidget.dem_creation_topo_layer_comboBox, self.polygonAndPointLayerNames)
        populateComboBox(self.dockwidget.dem_creation_aggregate_type_comboBox, [key.title() for key in AGGREGATES.keys()])
        populateComboBox(self.dockwidget.dem_creation_interpolation_method_comboBox, [key.title() for key in INTERPOLATIONS.keys()])
        populateComboBox(self.dockwidget.dem_creation_extent_layer_comboBox, self.vectorLayerNames)
        populateComboBox(self.dockwidget.profile_creation_intersect_layer_comboBox, [LABELS['None']] + self.polygonLayerNames)
        populateComboBox(self.dockwidget.link_creation_links_layer_comboBox, self.noGeomLayerNames)
        populateComboBox(self.dockwidget.link_projection_links_layer_comboBox, self.lineLayerNames)
        populateComboBox(self.dockwidget.atlas_configuring_layout_name_comboBox, [NEW_LAYOUT_TEXT] + self.layoutNames)
        populateComboBox(self.dockwidget.connection_lines_creation_layout_comboBox, self.layoutNames)
        
        for box in self.axisLayerComboBoxes:
            populateComboBox(box, self.lineLayerNames)

        for box in self.objectsLayerComboBoxes:
            populateComboBox(box, self.polygonAndPointLayerNames)

        # For layer selection combo boxes, set value to first selected layer if applicable

        self.topo_layer = self.setValueToSelectedLayer(self.topo_layer, self.polygonAndPointLayers)
        self.extent_layer = self.setValueToSelectedLayer(self.extent_layer, self.vectorLayers)
        self.axis_layer = self.setValueToSelectedLayer(self.axis_layer, self.lineLayers)
        self.intersect_layer = self.setValueToSelectedLayer(self.intersect_layer, self.polygonLayers)
        self.objects_layer = self.setValueToSelectedLayer(self.objects_layer, self.polygonAndPointLayers)
        self.link_creation_links_layer = self.setValueToSelectedLayer(self.link_creation_links_layer, self.noGeomLayers)
        self.link_projection_links_layer = self.setValueToSelectedLayer(self.link_projection_links_layer, self.lineLayers)

        self.init = False

        # Update combo boxes according to value

        setComboBoxIndex(self.dockwidget.dem_creation_topo_layer_comboBox, self.topo_layer)
        setComboBoxIndex(self.dockwidget.profile_creation_intersect_layer_comboBox, self.intersect_layer)
        setComboBoxIndex(self.dockwidget.link_creation_links_layer_comboBox, self.link_creation_links_layer)
        setComboBoxIndex(self.dockwidget.link_projection_links_layer_comboBox, self.link_projection_links_layer)
        setComboBoxIndex(self.dockwidget.dem_creation_extent_layer_comboBox, self.extent_layer)

        setComboBoxIndex(self.dockwidget.dem_creation_aggregate_type_comboBox)
        setComboBoxIndex(self.dockwidget.dem_creation_interpolation_method_comboBox)
        setComboBoxIndex(self.dockwidget.atlas_configuring_layout_name_comboBox)
        setComboBoxIndex(self.dockwidget.connection_lines_creation_layout_comboBox)

        setComboBoxIndex(self.axisLayerComboBoxes[0], self.axis_layer)

        setComboBoxIndex(self.objectsLayerComboBoxes[0], self.objects_layer)

        # Populate list views with relevant list

        for view in self.demListViews:
            populateListView(view, self.demLayerNames)

        for view in self.vectorLayerListViews:
            populateListView(view, self.vectorLayerNames)

        # Enable all list views and combo boxes
        self.dockwidget.dockWidgetContents.setEnabled(True)
        self.dockwidget.progress_indicator.stopAnimation()
        self.dockwidget.progress_indicator.setVisible(False)

        #QApplication.restoreOverrideCursor()

    #--------------------------------------------------------------------------

    def initDemCreationWidget(self):
        """Initializes DEM creation interface"""

        # Handle altitude field combo box modification

        self.dockwidget.dem_creation_altitude_field_comboBox.currentIndexChanged.connect(self.dem_creation_altitude_field_comboBox_changed)

        # Handle source layer combo box modification

        self.dockwidget.dem_creation_topo_layer_comboBox.currentIndexChanged.connect(self.dem_creation_topo_layer_comboBox_changed)

        # Handle aggregate type combo box modification

        self.dockwidget.dem_creation_aggregate_type_comboBox.currentIndexChanged.connect(self.dem_creation_aggregate_type_comboBox_changed)

        # Handle interpolation method combo box modification

        self.dockwidget.dem_creation_interpolation_method_comboBox.currentIndexChanged.connect(self.dem_creation_interpolation_method_comboBox_changed)

        # Initialize extent radio buttons

        radio0 = self.dockwidget.dem_creation_extent_layer_radioButton
        radio1 = self.dockwidget.dem_creation_extent_coords_radioButton

        ## Set other elements visibility

        self.dockwidget.dem_creation_extent_lineEdit.setVisible(self.dem_creation_extent_method == 1)

        ## Handle modification

        radio0.toggled.connect(self.dem_creation_extent_layer_radioButton_toggled)
        radio1.toggled.connect(self.dem_creation_extent_coords_radioButton_toggled)

        # Handle extent layer combo box modification

        self.dockwidget.dem_creation_extent_layer_comboBox.currentIndexChanged.connect(self.dem_creation_extent_layer_comboBox_changed)

        # Initialize clipping check box

        checkBox = self.dockwidget.dem_creation_clipping_checkBox

        ## Handle modification

        checkBox.stateChanged.connect(self.dem_creation_clipping_checkBox_changed)

        # Initialize extent coords line edit

        lineEdit = self.dockwidget.dem_creation_extent_lineEdit

        ## Handle modification

        lineEdit.textChanged.connect(self.dem_creation_extent_lineEdit_changed)

        # Initialize distance spin box

        spinBox = self.dockwidget.dem_creation_distance_doubleSpinBox

        ## Handle modification

        spinBox.valueChanged.connect(self.dem_creation_distance_doubleSpinBox_changed)

        # Initialize resolution spin box

        spinBox = self.dockwidget.dem_creation_resolution_doubleSpinBox

        ## Handle modification

        spinBox.valueChanged.connect(self.dem_creation_resolution_doubleSpinBox_changed)

        # Initialize expression widget

        expressionBox = self.dockwidget.dem_creation_filter_expression_widget

        ## Set layer

        expressionBox.setLayer(self.topo_layer)

        # Set up push button

        button = self.dockwidget.dem_creation_pushButton

        button.clicked.connect(self.dem_creation_run)

        # Hide all check labels

        self.dockwidget.dem_creation_topo_layer_checkLabel.setVisible(False)
        self.dockwidget.dem_creation_altitude_field_checkLabel.setVisible(False)
        self.dockwidget.dem_creation_extent_checkLabel.setVisible(False)
        self.dockwidget.dem_creation_filter_expression_checkLabel.setVisible(False)

    #--------------------------------------------------------------------------

    def dem_creation_topo_layer_comboBox_changed(self):
        """Handles modification of the DEM creation topo layer combo box"""

        layerName = self.dockwidget.dem_creation_topo_layer_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for layer in self.polygonAndPointLayers:
                if layer.name() == layerName:
                    self.topo_layer = layer

        # Sync related combo boxes
        if not self.init:
            syncComboBoxes(self.dockwidget.dem_creation_topo_layer_comboBox, self.axisLayerComboBoxes, self.axis_layer)

        # Change items in the altitude fields combo box

        fieldComboBox = self.dockwidget.dem_creation_altitude_field_comboBox

        ## List numeric fields in the source layer

        if self.topo_layer != None:
            self.sourceLayerNumericFields = listNumericFields(self.topo_layer)
            self.sourceLayerNumericFieldNames = listFieldNames(self.sourceLayerNumericFields)

        ## Add items

        fieldComboBox.clear()
        if self.sourceLayerNumericFieldNames != None and len(self.sourceLayerNumericFieldNames) > 0:
            fieldComboBox.addItems(self.sourceLayerNumericFieldNames)

        ## Set default value

        fieldComboBox.setCurrentIndex(0)

        # Change filter expression context

        self.dockwidget.dem_creation_filter_expression_widget.setLayer(self.topo_layer)

    def dem_creation_altitude_field_comboBox_changed(self):
        """Handles modification of the DEM creation altitude field combo box"""

        fieldName = self.dockwidget.dem_creation_altitude_field_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for field in self.sourceLayerNumericFields:
                if field.name() == fieldName:
                    self.altitude_field = field.name()

        # Sync related combo boxes
        if not self.init:
            syncComboBoxes(self.dockwidget.dem_creation_altitude_field_comboBox, self.altitudeFieldComboBoxes, self.altitude_field)

    def dem_creation_aggregate_type_comboBox_changed(self):
        """Handles modification of the DEM creation aggregate type combo box"""

        aggregateName = self.dockwidget.dem_creation_aggregate_type_comboBox.currentText()

        # Modifies the value

        if not self.init:

            if aggregateName.lower() in AGGREGATES.keys():
                self.dem_creation_aggregate_type = AGGREGATES[aggregateName.lower()]

    def dem_creation_interpolation_method_comboBox_changed(self):
        """Handles modification of the DEM creation interpolation method combo box"""

        interpolation = self.dockwidget.dem_creation_interpolation_method_comboBox.currentText()

        # Modifies the value

        if not self.init:

            if interpolation in INTERPOLATIONS.keys():
                self.dem_creation_interpolation_method = INTERPOLATIONS[interpolation]

    def dem_creation_extent_layer_radioButton_toggled(self, on):
        """Handles modification of the DEM creation extent layer radio button"""

        # Modifies the value

        if on:
            self.dem_creation_extent_method = 0

            ## Set other elements visibility

            self.dockwidget.dem_creation_extent_lineEdit.setVisible(False)
            self.dockwidget.dem_creation_extent_layer_comboBox.setVisible(True)
            self.dockwidget.dem_creation_clipping_checkBox.setVisible(True)

    def dem_creation_extent_coords_radioButton_toggled(self, on):
        """Handles modification of the DEM creation extent coordinates radio button"""

        # Modifies the value

        if on:
            self.dem_creation_extent_method = 1

            ## Set other elements visibility

            self.dockwidget.dem_creation_extent_layer_comboBox.setVisible(False)
            self.dockwidget.dem_creation_clipping_checkBox.setVisible(False)
            self.dockwidget.dem_creation_extent_lineEdit.setVisible(True)

    def dem_creation_extent_layer_comboBox_changed(self):
        """Handles modification of the DEM creation extent layer combo box"""

        layerName = self.dockwidget.dem_creation_extent_layer_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for layer in self.vectorLayers:
                if layer.name() == layerName:
                    self.extent_layer = layer

                    # Modifies the coords value

                    ext = self.extent_layer.extent()
                    xmin = ext.xMinimum()
                    xmax = ext.xMaximum()
                    ymin = ext.yMinimum()
                    ymax = ext.yMaximum()
                    self.dockwidget.dem_creation_extent_lineEdit.setText("%f,%f,%f,%f" %(xmin, xmax, ymin, ymax))

    def dem_creation_clipping_checkBox_changed(self):
        """Handles modification of the DEM creation clipping check box"""

        # Modifies the value

        if self.dockwidget.dem_creation_clipping_checkBox.isChecked():
            self.dem_creation_clipping = True
        else:
            self.dem_creation_clipping = False

    def dem_creation_extent_lineEdit_changed(self):
        """Handles modification of the DEM creation extent coordinates line edit"""

        # Modifies the value

        self.dem_creation_extent_coords = self.dockwidget.dem_creation_extent_lineEdit.text().replace(' ', '')

    def dem_creation_distance_doubleSpinBox_changed(self):
        """Handles modification of the DEM creation distance spin box"""

        # Modifies the value

        self.dem_creation_distance = self.dockwidget.dem_creation_distance_doubleSpinBox.value()

    def dem_creation_resolution_doubleSpinBox_changed(self):
        """Handles modification of the DEM creation resolution spin box"""

        # Modifies the value

        self.dem_creation_resolution = self.dockwidget.dem_creation_resolution_doubleSpinBox.value()

    def dem_creation_checkParameters(self):
        """Check DEM creation input parameters"""

        errors = 0

        # Check source layer parameter

        if self.topo_layer == None:
            self.dockwidget.dem_creation_topo_layer_checkLabel.setText("Vous devez sélectionner une couche source.")
            self.dockwidget.dem_creation_topo_layer_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.dem_creation_topo_layer_checkLabel.setVisible(False)

        # Check altitude field parameter

        if self.altitude_field == None:
            self.dockwidget.dem_creation_altitude_field_checkLabel.setText("Vous devez sélectionner un champ d'altitude.")
            self.dockwidget.dem_creation_altitude_field_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.dem_creation_altitude_field_checkLabel.setVisible(False)

        # Check extent parameter

        if (self.dem_creation_extent_method == 0 and self.extent_layer == None) or (self.dem_creation_extent_method == 1 and self.dem_creation_extent_coords == ''):
            self.dockwidget.dem_creation_extent_checkLabel.setText("Vous devez sélectionner une extension.")
            self.dockwidget.dem_creation_extent_checkLabel.setVisible(True)
            errors += 1

        elif self.dem_creation_extent_method == 1 and not re.match('^(\d+(\.\d+)*),(\d+(\.\d+)*),(\d+(\.\d+)*),(\d+(\.\d+)*)$', self.dem_creation_extent_coords):
            self.dockwidget.dem_creation_extent_checkLabel.setText("L'extension n'est pas valide.")
            self.dockwidget.dem_creation_extent_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.dem_creation_extent_checkLabel.setVisible(False)

        # Check filter expression

        ## Check whether expression is valid

        if not self.dockwidget.dem_creation_filter_expression_widget.isValidExpression():
            self.dockwidget.dem_creation_filter_expression_checkLabel.setText("L'expression n'est pas valide.")
            self.dockwidget.dem_creation_filter_expression_checkLabel.setVisible(True)
            errors += 1

        ## Check whether expression matches any entities from the source layer

        elif self.topo_layer != None:
            features = self.topo_layer.getFeatures(self.dockwidget.dem_creation_filter_expression_widget.expression())

            empty = True
            for feature in features:
                empty = False
                break

            if empty:
                self.dockwidget.dem_creation_filter_expression_checkLabel.setText("Aucune entité de la couche source ne vérifie cette expression.")
                self.dockwidget.dem_creation_filter_expression_checkLabel.setVisible(True)
                errors += 1

            else:
                self.dem_creation_filter_expression = self.dockwidget.dem_creation_filter_expression_widget.expression()
                self.dockwidget.dem_creation_filter_expression_checkLabel.setVisible(False)

        else:
            self.dem_creation_filter_expression = self.dockwidget.dem_creation_filter_expression_widget.expression()
            self.dockwidget.dem_creation_filter_expression_checkLabel.setVisible(False)

        # Return boolean according to number of errors

        return (errors == 0)

    def dem_creation_run(self):
        """Handles clicking on the DEM creation run button"""

        # Check parameters

        if self.dem_creation_checkParameters():

            # Block all push buttons

            self.setEnabledPushButtons(False)

            # Set up extent parameter according to chosen extent method

            if self.dem_creation_extent_method == 0:
                self.dem_creation_extent = self.extent_layer
            else:
                self.dem_creation_extent = self.dem_creation_extent_coords

            # Run algorithm
            
            self.dockwidget.progressBar.setValue(0)
            dem = createDEM(self.topo_layer, 
                            self.altitude_field, 
                            self.dem_creation_extent, 
                            self.dem_creation_distance, 
                            self.dem_creation_filter_expression, 
                            self.dem_creation_aggregate_type, 
                            self.dem_creation_interpolation_method, 
                            self.dem_creation_resolution, 
                            self.dem_creation_clipping, 
                            self.dockwidget.progressBar)

            # Check result

            if dem == None:
                debug_print("Error while creating DEM")
                self.setEnabledPushButtons(True)
                return

            # Load new layer

            if not dem.isValid():
                debug_print("New DEM layer failed to load!")
                return
            else:
                QgsProject.instance().addMapLayer(dem)

            # Enable all push buttons

            self.setEnabledPushButtons(True)

    #--------------------------------------------------------------------------

    def initDemCorrectionWidget(self):
        """Initializes DEM correction interface"""

        # Handle modification of DEM list items

        self.dockwidget.dem_correction_dems_listView_model = QStandardItemModel()
        self.dockwidget.dem_correction_dems_listView.setModel(self.dockwidget.dem_correction_dems_listView_model)
        self.dockwidget.dem_correction_dems_listView_model.itemChanged.connect(self.dem_correction_dems_listView_itemChanged)

        # Initialize rules table

        tableWidget = self.dockwidget.dem_correction_rules_tableWidget

        ## Set up headers

        tableWidget.setHorizontalHeaderLabels(["MNT stable", "Relation stratigraphique", "MNT à modifier"])
        tableWidget.horizontalHeader().setStretchLastSection(True)

        # Initialize add rule button

        button = self.dockwidget.dem_correction_add_rule_pushButton
        button.setEnabled(False)

        button.clicked.connect(self.dem_correction_add_rule)

        # Initialize delete rule button

        button = self.dockwidget.dem_correction_delete_rule_pushButton
        button.setEnabled(False)

        button.clicked.connect(self.dem_correction_delete_rule)

        # Set up push button

        button = self.dockwidget.dem_correction_pushButton

        button.clicked.connect(self.dem_correction_run)

        # Hide all check labels

        self.dockwidget.dem_correction_dems_checkLabel.setVisible(False)
        self.dockwidget.dem_correction_rules_checkLabel.setVisible(False)

    #--------------------------------------------------------------------------

    def dem_correction_dems_listView_itemChanged(self, item):
        """Handles modification of DEM correcting dem list item"""

        # Add or remove corresponding DEM

        if item.checkState():

            ## Add corresponding layer to list

            for layer in self.demLayers:
                if layer.name() == item.text():
                    if layer not in self.demList:
                        self.demList.append(layer)

        else:

            ## Remove corresponding layer from list

            for layer in self.demLayers:
                if layer.name() == item.text():
                    if layer in self.demList:
                        self.demList.remove(layer)

        # Reorder list

        newList = []

        for layer in self.demLayers:
            if layer in self.demList:
                newList.append(layer)

        self.demList = newList

        # Sync related list views

        if not self.init:
            syncListViews(self.dockwidget.dem_correction_dems_listView, self.demListViews, self.demList)

        # Enable or disable add rule button

        if len(self.demList) > 1:
            self.dockwidget.dem_correction_add_rule_pushButton.setEnabled(True)
        else:
            self.dockwidget.dem_correction_add_rule_pushButton.setEnabled(False)

    def dem_correction_add_rule(self):
        """Adds a rule to the list"""

        # Do nothing if less than 2 DEM has been checked

        if len(self.demList) < 2:
            return

        # Add row at bottom of table

        tableWidget = self.dockwidget.dem_correction_rules_tableWidget

        row = tableWidget.rowCount()

        tableWidget.insertRow(row)

        # Populate first column

        layerList = []

        index = 0
        while index < len(self.demList):
            if tableWidget.cellWidget(row, 2) != None:
                if index != tableWidget.cellWidget(row, 2).currentIndex():
                    layerList.append(self.demList[index].name())
            else:
                layerList.append(self.demList[index].name())

            index += 1

        layerList = sorted(layerList)

        boxCell = QComboBox()
        boxCell.addItems(layerList)
        boxCell.setCurrentIndex(0)

        parentLayerName = layerList[0]

        parentLayer = None
        for layer in self.demList:
            if layer.name() == parentLayerName:
                parentLayer = layer

        tableWidget.setCellWidget(row, 0, boxCell)

        # Handle modification of first column

        boxCell.activated.connect(lambda: self.parentLayerBoxCell_changed(boxCell.currentText()))

        # Populate second column

        boxCell = QComboBox()
        boxCell.addItems(["sur", "sous"])
        boxCell.setCurrentIndex(0)

        tableWidget.setCellWidget(row, 1, boxCell)

        # Handle modification of second column

        boxCell.activated.connect(lambda: self.relationBoxCell_changed(boxCell.currentIndex()))

        # Populate third column

        layerList = []

        index = 0
        while index < len(self.demList):
            if tableWidget.cellWidget(row, 0) != None:
                if index != tableWidget.cellWidget(row, 0).currentIndex():
                    layerList.append(self.demList[index].name())
            else:
                layerList.append(self.demList[index].name())

            index += 1

        layerList = sorted(layerList)

        boxCell = QComboBox()
        boxCell.addItems(layerList)
        boxCell.setCurrentIndex(0)

        childLayerName = layerList[0]

        childLayer = None
        for layer in self.demList:
            if layer.name() == childLayerName:
                childLayer = layer

        tableWidget.setCellWidget(row, 2, boxCell)

        # Handle modification of third column

        boxCell.activated.connect(lambda: self.childLayerBoxCell_changed(boxCell.currentText()))

        # Select first column of new row

        tableWidget.setCurrentCell(row, 0)

        # Add rule to list

        parentLayerIndex = None
        childLayerIndex = None
        index = 0
        while index < len(self.demList):
            layer = self.demList[index]
            if layer == parentLayer:
                parentLayerIndex = index
            elif layer == childLayer:
                childLayerIndex = index

            index += 1

        if childLayerIndex == None or parentLayerIndex == None:
            debug_print('Error encountered while editing rule')
            return

        self.rules.append({'parent': parentLayerIndex, 'position': 0, 'child': childLayerIndex})

        # Enable or disable delete rule button

        if len(self.rules) > 0:
            self.dockwidget.dem_correction_delete_rule_pushButton.setEnabled(True)
        else:
            self.dockwidget.dem_correction_delete_rule_pushButton.setEnabled(False)

    def dem_correction_delete_rule(self):
        """Removes a rule from the list"""

        # Get indices of selected rules

        tableWidget = self.dockwidget.dem_correction_rules_tableWidget

        indices = tableWidget.selectionModel().selectedRows()

        rows = []
        for index in indices:
            rows.append(index.row())

        #print(rows)

        # Remove rows

        for index in sorted(indices, reverse=True):
            tableWidget.removeRow(index.row())

        # Delete corresponding rules

        newRules = []

        index = 0
        while index < len(self.rules):
            rule = self.rules[index]

            if index not in rows:
                newRules.append(rule)

            index += 1

        self.rules = newRules

        # Enable or disable delete rule button

        if len(self.rules) > 0:
            self.dockwidget.dem_correction_delete_rule_pushButton.setEnabled(True)
        else:
            self.dockwidget.dem_correction_delete_rule_pushButton.setEnabled(False)

    def parentLayerBoxCell_changed(self, layer_name):
        """Handles modification of rule parent layer"""

        # Get index of modified rule

        tableWidget = self.dockwidget.dem_correction_rules_tableWidget

        index = tableWidget.currentIndex().row()

        # Get parent layer from name

        parentLayerIndex = None
        i = 0
        while i < len(self.demList):
            layer = self.demList[i]
            if layer.name() == layer_name:
                parentLayerIndex = i

            i += 1

        if parentLayerIndex == None:
            debug_print('Error encountered while editing parent DEM layer')
            return

        # Edit rule

        newRules = []

        i = 0
        while i < len(self.rules):
            rule = self.rules[i]
            if i != index:
                newRules.append(rule)
            else:
                newRules.append({'parent': parentLayerIndex, 'position': rule['position'], 'child': rule['child']})

            i += 1

        self.rules = newRules

        # Edit child layer combo box

        ## Edit available values

        layerList = []

        parentCombo = tableWidget.cellWidget(index, 0)
        childCombo = tableWidget.cellWidget(index, 2)

        i = 0
        while i < len(self.demList):
            if parentCombo != None:
                if self.demList[i].name() != parentCombo.currentText():
                    layerList.append(self.demList[i].name())
            else:
                layerList.append(self.demList[i].name())

            i += 1

        layerList = sorted(layerList)

        childLayerName = childCombo.currentText()

        childCombo.clear()
        childCombo.addItems(layerList)

        childIndex = None

        i = 0
        while i < len(layerList):
            layer = layerList[i]
            if layer == childLayerName:
                childIndex = i

            i += 1

        ## Edit current index

        if childIndex != None:

            childCombo.setCurrentIndex(childIndex)

        else:
            childCombo.setCurrentIndex(0)
            self.childLayerBoxCell_changed(childCombo.currentText())

    def childLayerBoxCell_changed(self, layer_name):
        """Handles modification of rule child layer"""

        # Get index of modified rule

        tableWidget = self.dockwidget.dem_correction_rules_tableWidget

        index = tableWidget.currentIndex().row()

        # Get child layer from name

        childLayerIndex = None
        i = 0
        while i < len(self.demList):
            layer = self.demList[i]
            if layer.name() == layer_name:
                childLayerIndex = i

            i += 1

        if childLayerIndex == None:
            debug_print('Error encountered while editing child DEM layer')
            return

        # Edit rule

        newRules = []

        i = 0
        while i < len(self.rules):
            rule = self.rules[i]
            if i != index:
                newRules.append(rule)
            else:
                newRules.append({'parent': rule['parent'], 'position': rule['position'], 'child': childLayerIndex})

            i += 1

        self.rules = newRules

        # Edit parent layer combo box

        ## Edit available values

        layerList = []

        parentCombo = tableWidget.cellWidget(index, 0)
        childCombo = tableWidget.cellWidget(index, 2)

        i = 0
        while i < len(self.demList):
            if childCombo != None:
                if self.demList[i].name() != childCombo.currentText():
                    layerList.append(self.demList[i].name())
            else:
                layerList.append(self.demList[i].name())

            i += 1

        layerList = sorted(layerList)

        parentLayerName = parentCombo.currentText()

        parentCombo.clear()
        parentCombo.addItems(layerList)

        parentIndex = None

        i = 0
        while i < len(layerList):
            layer = layerList[i]
            if layer == parentLayerName:
                parentIndex = i

            i += 1

        ## Edit current index

        if parentIndex != None:

            parentCombo.setCurrentIndex(parentIndex)

        else:
            parentCombo.setCurrentIndex(0)
            self.parentLayerBoxCell_changed(parentCombo.currentText())

    def relationBoxCell_changed(self, item_index):
        """Handles modification of rule relation"""

        # Get index of modified rule

        tableWidget = self.dockwidget.dem_correction_rules_tableWidget

        index = tableWidget.currentIndex().row()

        # Edit rule

        newRules = []

        i = 0
        while i < len(self.rules):
            rule = self.rules[i]
            if i != index:
                newRules.append(rule)
            else:
                newRules.append({'parent': rule['parent'], 'position': item_index, 'child': rule['child']})

            i += 1

        self.rules = newRules

    def dem_correction_checkParameters(self):
        """Check DEM correction input parameters"""

        errors = 0

        # Check DEM layers list parameter

        if len(self.demList) < 1:
            self.dockwidget.dem_correction_dems_checkLabel.setText("Vous devez sélectionner au moins 2 MNT à corriger.")
            self.dockwidget.dem_correction_dems_checkLabel.setVisible(True)
            errors += 1

        else:

            self.dockwidget.dem_correction_dems_checkLabel.setVisible(False)

        # Check rules parameter

        if len(self.rules) < 1:
            self.dockwidget.dem_correction_rules_checkLabel.setText("Vous devez ajouter au moins une règle stratigraphique.")
            self.dockwidget.dem_correction_rules_checkLabel.setVisible(True)
            errors += 1

        else:
            ruleErrors = 0
            i = 0
            while i < len(self.rules):
                rule = self.rules[i]
                if rule['parent'] == None or rule['child'] == None or rule['parent'] == rule['child'] or rule['parent'] > len(self.demList) or rule['child'] > len(self.demList):
                    self.dockwidget.dem_correction_rules_checkLabel.setText("Vous devez sélectionner un MNT stable et un MNT à corriger différents pour chaque règle stratigraphique.")
                    self.dockwidget.dem_correction_rules_checkLabel.setVisible(True)
                    errors += 1
                    ruleErrors += 1
                    break
                j = 0
                while j < len(self.rules):
                    anotherRule = self.rules[j]
                    if anotherRule == rule and i != j:
                        self.dockwidget.dem_correction_rules_checkLabel.setText("Au moins 2 des règles stratigraphiques sont identiques. Veuillez en supprimer une.")
                        self.dockwidget.dem_correction_rules_checkLabel.setVisible(True)
                        errors += 1
                        ruleErrors += 1
                        break
                        break
                    if (anotherRule['child'] == rule['parent'] and anotherRule['parent'] == rule['child'] and anotherRule['position'] != rule['position']) or (anotherRule['child'] == rule['child'] and anotherRule['parent'] == rule['parent'] and anotherRule['position'] != rule['position']):
                        self.dockwidget.dem_correction_rules_checkLabel.setText("Au moins 2 des règles stratigraphiques sont incompatibles. Veuillez en supprimer une.")
                        self.dockwidget.dem_correction_rules_checkLabel.setVisible(True)
                        errors += 1
                        ruleErrors += 1
                        break
                        break

                    j += 1

                i += 1

            if ruleErrors == 0:
                self.dockwidget.dem_correction_rules_checkLabel.setVisible(False)

        # Return boolean according to number of errors

        return (errors == 0)

    def dem_correction_run(self):
        """Handles clicking on the DEM correction run button"""

        # Check parameters

        if self.dem_correction_checkParameters():

            # Block all push buttons

            self.setEnabledPushButtons(False)

            # Run algorithm
            
            self.dockwidget.progressBar.setValue(0)
            newDems = correctDEMs(self.demList, self.rules, self.dockwidget.progressBar)

            # Check result

            if newDems == None:
                debug_print("Error while correcting DEMs")
                self.setEnabledPushButtons(True)
                return

            # Load new layers

            for dem in newDems:
                if not dem.isValid():
                    debug_print("Corrected DEM layer " + dem.name() + " failed to load!")
                    return
                else:
                    QgsProject.instance().addMapLayer(dem)

            # Enable all push buttons

            self.setEnabledPushButtons(True)

    #--------------------------------------------------------------------------

    def initDemHarmonizationWidget(self):
        """Initializes DEM harmonization interface"""

        # Handle modification of DEM list items

        self.dockwidget.dem_harmonization_dems_listView_model = QStandardItemModel()
        self.dockwidget.dem_harmonization_dems_listView.setModel(self.dockwidget.dem_harmonization_dems_listView_model)
        self.dockwidget.dem_harmonization_dems_listView_model.itemChanged.connect(self.dem_harmonization_dems_listView_itemChanged)

        # Initialize gradient button

        button = self.dockwidget.dem_harmonization_gradient_toolButton

        ## Handle modification of gradient

        button.colorRampChanged.connect(self.dem_harmonization_gradient_changed)

        # Initialize interval spin box

        spinBox = self.dockwidget.dem_harmonization_interval_doubleSpinBox

        ## Handle modification of interval

        spinBox.valueChanged.connect(self.dem_harmonization_interval_doubleSpinBox_changed)

        # Initialize contour checkbox

        checkBox = self.dockwidget.dem_harmonization_contour_checkBox

        ## Hide contour elevation field name line edit

        self.dockwidget.dem_harmonization_contour_elevation_field_lineEdit.setVisible(self.dem_harmonization_contour)
        self.dockwidget.dem_harmonization_contour_elevation_field_label.setVisible(self.dem_harmonization_contour)

        ## Handle modification of contour boolean

        checkBox.stateChanged.connect(self.dem_harmonization_contour_checkBox_changed)

        # Initialize contour elevation field name

        lineEdit = self.dockwidget.dem_harmonization_contour_elevation_field_lineEdit

        self.dem_harmonization_contour_elevation_field_name = lineEdit.text()

        ## Handle modification of contour elevation field name

        lineEdit.textChanged.connect(self.dem_harmonization_contour_elevation_field_lineEdit_changed)

        # Initialize hillshade checkbox

        checkBox = self.dockwidget.dem_harmonization_hillshade_checkBox

        ## Hide hillshade fields

        self.dockwidget.dem_harmonization_z_factor_doubleSpinBox.setVisible(self.dem_harmonization_hillshade)
        self.dockwidget.dem_harmonization_z_factor_label.setVisible(self.dem_harmonization_hillshade)
        self.dockwidget.dem_harmonization_azimuth_doubleSpinBox.setVisible(self.dem_harmonization_hillshade)
        self.dockwidget.dem_harmonization_azimuth_label.setVisible(self.dem_harmonization_hillshade)
        self.dockwidget.dem_harmonization_vertical_angle_doubleSpinBox.setVisible(self.dem_harmonization_hillshade)
        self.dockwidget.dem_harmonization_vertical_angle_label.setVisible(self.dem_harmonization_hillshade)

        ## Handle modification of hillshade boolean

        checkBox.stateChanged.connect(self.dem_harmonization_hillshade_checkBox_changed)

        # Initialize Z factor spin box

        spinBox = self.dockwidget.dem_harmonization_z_factor_doubleSpinBox

        ## Set default value

        self.dem_harmonization_z_factor = spinBox.value()

        ## Handle modification of Z factor

        spinBox.valueChanged.connect(self.dem_harmonization_z_factor_doubleSpinBox_changed)

        # Initialize azimuth spin box

        spinBox = self.dockwidget.dem_harmonization_azimuth_doubleSpinBox

        ## Set default value

        self.dem_harmonization_azimuth = spinBox.value()

        ## Handle modification of azimuth

        spinBox.valueChanged.connect(self.dem_harmonization_azimuth_doubleSpinBox_changed)

        # Initialize vertical angle spin box

        spinBox = self.dockwidget.dem_harmonization_vertical_angle_doubleSpinBox

        ## Set default value

        self.dem_harmonization_vertical_angle = spinBox.value()

        ## Handle modification of vertical angle

        spinBox.valueChanged.connect(self.dem_harmonization_vertical_angle_doubleSpinBox_changed)

        # Set up push button

        button = self.dockwidget.dem_harmonization_pushButton

        button.clicked.connect(self.dem_harmonization_run)

        # Hide all check labels

        self.dockwidget.dem_harmonization_dems_checkLabel.setVisible(False)
        self.dockwidget.dem_harmonization_gradient_checkLabel.setVisible(False)
        self.dockwidget.dem_harmonization_contour_elevation_field_name_checkLabel.setVisible(False)

    #--------------------------------------------------------------------------

    def dem_harmonization_dems_listView_itemChanged(self, item):
        """Handles modification of DEM harmonization dem list item"""

        # Add or remove corresponding DEM

        if item.checkState():

            ## Add corresponding layer to list

            for layer in self.demLayers:
                if layer.name() == item.text():
                    if layer not in self.demList:
                        self.demList.append(layer)

        else:

            ## Remove corresponding layer from list

            for layer in self.demLayers:
                if layer.name() == item.text():
                    if layer in self.demList:
                        self.demList.remove(layer)

        # Reorder list

        newList = []

        for layer in self.demLayers:
            if layer in self.demList:
                newList.append(layer)

        self.demList = newList

        # Sync related list views

        if not self.init:
            syncListViews(self.dockwidget.dem_harmonization_dems_listView, self.demListViews, self.demList)

    def dem_harmonization_gradient_changed(self):
        """Handles modification of DEM harmonization gradient"""

        # Update gradient value

        button = self.dockwidget.dem_harmonization_gradient_toolButton

        if not button.isNull():

            self.dem_harmonization_gradient = button.colorRamp()

        else:

            self.dem_harmonization_gradient = None

    def dem_harmonization_interval_doubleSpinBox_changed(self):
        """Handles modification of DEM harmonization interval"""

        # Update value

        self.dem_harmonization_interval = self.dockwidget.dem_harmonization_interval_doubleSpinBox.value()

    def dem_harmonization_contour_checkBox_changed(self):
        """Handles modification of DEM harmonization contour boolean"""

        # Modifies the value

        self.dem_harmonization_contour = self.dockwidget.dem_harmonization_contour_checkBox.isChecked()

        # Hide or show contour elevation field accordingly

        self.dockwidget.dem_harmonization_contour_elevation_field_lineEdit.setVisible(self.dem_harmonization_contour)
        self.dockwidget.dem_harmonization_contour_elevation_field_label.setVisible(self.dem_harmonization_contour)

    def dem_harmonization_contour_elevation_field_lineEdit_changed(self):
        """Handles modification of DEM harmonization contour elevation field name"""

        # Update value

        self.dem_harmonization_contour_elevation_field_name = self.dockwidget.dem_harmonization_contour_elevation_field_lineEdit.text()

    def dem_harmonization_hillshade_checkBox_changed(self):
        """Handles modification of DEM harmonization hillshade boolean"""

        # Modifies the value

        self.dem_harmonization_hillshade = self.dockwidget.dem_harmonization_hillshade_checkBox.isChecked()

        # Hide or show hillshade fields accordingly

        self.dockwidget.dem_harmonization_z_factor_doubleSpinBox.setVisible(self.dem_harmonization_hillshade)
        self.dockwidget.dem_harmonization_z_factor_label.setVisible(self.dem_harmonization_hillshade)
        self.dockwidget.dem_harmonization_azimuth_doubleSpinBox.setVisible(self.dem_harmonization_hillshade)
        self.dockwidget.dem_harmonization_azimuth_label.setVisible(self.dem_harmonization_hillshade)
        self.dockwidget.dem_harmonization_vertical_angle_doubleSpinBox.setVisible(self.dem_harmonization_hillshade)
        self.dockwidget.dem_harmonization_vertical_angle_label.setVisible(self.dem_harmonization_hillshade)

    def dem_harmonization_z_factor_doubleSpinBox_changed(self):
        """Handles modification of DEM harmonization Z factor"""

        # Update value

        self.dem_harmonization_z_factor = self.dockwidget.dem_harmonization_z_factor_doubleSpinBox.value()

    def dem_harmonization_azimuth_doubleSpinBox_changed(self):
        """Handles modification of DEM harmonization azimuth"""

        # Update value

        self.dem_harmonization_azimuth = self.dockwidget.dem_harmonization_azimuth_doubleSpinBox.value()

    def dem_harmonization_vertical_angle_doubleSpinBox_changed(self):
        """Handles modification of DEM harmonization vertical angle"""

        # Update value

        self.dem_harmonization_vertical_angle = self.dockwidget.dem_harmonization_vertical_angle_doubleSpinBox.value()

    def dem_harmonization_checkParameters(self):
        """Check DEM harmonization input parameters"""

        errors = 0

        # Check DEM layers list parameter

        if len(self.demList) < 0:
            self.dockwidget.dem_harmonization_dems_checkLabel.setText("Vous devez sélectionner au moins un MNT.")
            self.dockwidget.dem_harmonization_dems_checkLabel.setVisible(True)
            errors += 1

        else:

            self.dockwidget.dem_harmonization_dems_checkLabel.setVisible(False)

        # Check gradient parameter

        if self.dem_harmonization_gradient == None:
            self.dockwidget.dem_harmonization_gradient_checkLabel.setText("Vous devez sélectionner un dégradé de couleurs.")
            self.dockwidget.dem_harmonization_gradient_checkLabel.setVisible(True)
            errors += 1

        else:

            self.dockwidget.dem_harmonization_gradient_checkLabel.setVisible(False)

        # Check contour elevation field name

        if self.dem_harmonization_contour_elevation_field_name == '':
            self.dockwidget.dem_harmonization_contour_elevation_field_name_checkLabel.setText("Vous devez entrer un nom de champ.")
            self.dockwidget.dem_harmonization_contour_elevation_field_name_checkLabel.setVisible(True)
            errors += 1

        elif len(self.dem_harmonization_contour_elevation_field_name) > 10:
            self.dockwidget.dem_harmonization_contour_elevation_field_name_checkLabel.setText("Le nom de champ est trop long.\n Veuillez entrer un nom de moins de 10 caractères.")
            self.dockwidget.dem_harmonization_contour_elevation_field_name_checkLabel.setVisible(True)
            errors += 1

        elif not self.dem_harmonization_contour_elevation_field_name[0].isalpha() or not re.match('^\w+$', self.dem_harmonization_contour_elevation_field_name):
            self.dockwidget.dem_harmonization_contour_elevation_field_name_checkLabel.setText("Le nom de champ est invalide.")
            self.dockwidget.dem_harmonization_contour_elevation_field_name_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.dem_harmonization_contour_elevation_field_name_checkLabel.setVisible(False)

        # Return boolean according to number of errors

        return (errors == 0)

    def dem_harmonization_run(self):
        """Handles clicking on the DEM harmonization run button"""

        # Check parameters

        if self.dem_harmonization_checkParameters():

            # Block all push buttons

            self.setEnabledPushButtons(False)

            # Run algorithm
            
            self.dockwidget.progressBar.setValue(0)
            results = processDEMs(self.demList, 
                                  self.dem_harmonization_gradient, 
                                  self.dem_harmonization_interval, 
                                  self.dem_harmonization_contour, 
                                  self.dem_harmonization_contour_elevation_field_name, 
                                  self.dem_harmonization_hillshade, 
                                  self.dem_harmonization_z_factor, 
                                  self.dem_harmonization_azimuth, 
                                  self.dem_harmonization_vertical_angle, 
                                  self.dockwidget.progressBar)

            # Check results

            if results == None or results == False:
                debug_print("Error while harmonizing DEMs")
                self.setEnabledPushButtons(True)
                return

            # Load new layers

            if type(results) is list:
                if self.dem_harmonization_contour:
                    contours = results[0]
                if self.dem_harmonization_hillshade:
                    hillshades = results[-1]

            ## Load contours

            if self.dem_harmonization_contour:
                for contour in contours:
                    if not contour.isValid():
                        debug_print("Contour layer " + contour.name() + " failed to load!")
                        return
                    else:
                        QgsProject.instance().addMapLayer(contour)

            ## Load hillshades

            if self.dem_harmonization_hillshade:
                for hillshade in hillshades:
                    if not hillshade.isValid():
                        debug_print("Hillshade layer " + hillshade.name() + " failed to load!")
                        return
                    else:
                        QgsProject.instance().addMapLayer(hillshade)

            # Enable all push buttons

            self.setEnabledPushButtons(True)

    #--------------------------------------------------------------------------

    def initProfileCreationWidget(self):
        """Initializes profile creation interface"""

        # Handle axis layer combo box modification

        self.dockwidget.profile_creation_axis_layer_comboBox.currentIndexChanged.connect(self.profile_creation_axis_layer_comboBox_changed)

        # Handle modification of DEM list items

        self.dockwidget.profile_creation_dems_listView_model = QStandardItemModel()
        self.dockwidget.profile_creation_dems_listView.setModel(self.dockwidget.profile_creation_dems_listView_model)
        self.dockwidget.profile_creation_dems_listView_model.itemChanged.connect(self.profile_creation_dems_listView_itemChanged)

        # Initialize vertical exaggeration spin box

        spinBox = self.dockwidget.profile_creation_vertical_exaggeration_spinBox

        ## Set default value

        self.vertical_exaggeration = spinBox.value()

        ## Handle modification of vertical exaggeration

        spinBox.valueChanged.connect(self.profile_creation_vertical_exaggeration_spinBox_changed)

        # Handle ID field combo box modification

        self.dockwidget.profile_creation_intersect_id_field_comboBox.currentIndexChanged.connect(self.profile_creation_intersect_id_field_comboBox_changed)

        # Handle intersection layer combo box modification

        self.dockwidget.profile_creation_intersect_layer_comboBox.currentIndexChanged.connect(self.profile_creation_intersect_layer_comboBox_changed)

        ## Hide ID field combo box and filter expression

        self.dockwidget.profile_creation_intersect_id_field_comboBox.setVisible(self.intersect_layer != None)
        self.dockwidget.profile_creation_intersect_id_field_label.setVisible(self.intersect_layer != None)
        self.dockwidget.profile_creation_intersect_filter_expression_widget.setVisible(self.intersect_layer != None)
        self.dockwidget.profile_creation_intersect_filter_expression_label.setVisible(self.intersect_layer != None)

        # Initialize expression widget

        expressionBox = self.dockwidget.profile_creation_intersect_filter_expression_widget

        ## Set layer

        expressionBox.setLayer(self.intersect_layer)

        # Initialize grid creation checkbox

        checkBox = self.dockwidget.profile_creation_grid_checkBox

        ## Hide interval spin box

        self.dockwidget.profile_creation_grid_interval_doubleSpinBox.setVisible(self.profile_creation_grid)
        self.dockwidget.profile_creation_grid_interval_label.setVisible(self.profile_creation_grid)

        ## Handle modification of grid creation boolean

        checkBox.stateChanged.connect(self.profile_creation_grid_checkBox_changed)

        # Initialize grid interval spin box

        spinBox = self.dockwidget.profile_creation_grid_interval_doubleSpinBox

        ## Set default value

        self.grid_interval = spinBox.value()

        ## Handle modification of grid interval

        spinBox.valueChanged.connect(self.profile_creation_grid_interval_doubleSpinBox_changed)

        # Initialize extremities creation checkbox

        checkBox = self.dockwidget.profile_creation_extremities_checkBox

        ## Handle modification of extremities boolean

        checkBox.stateChanged.connect(self.profile_creation_extremities_checkBox_changed)

        # Set up push button

        button = self.dockwidget.profile_creation_pushButton

        button.clicked.connect(self.profile_creation_run)

        # Hide all check labels

        self.dockwidget.profile_creation_dems_checkLabel.setVisible(False)
        self.dockwidget.profile_creation_intersect_id_field_checkLabel.setVisible(False)
        self.dockwidget.profile_creation_intersect_filter_expression_checkLabel.setVisible(False)

    #--------------------------------------------------------------------------

    def profile_creation_axis_layer_comboBox_changed(self):
        """Handles modification of the profile creation axis layer combo box"""

        layerName = self.dockwidget.profile_creation_axis_layer_comboBox.currentText()

        # Modify the value

        if not self.init:

            for layer in self.lineLayers:
                if layer.name() == layerName:
                    self.axis_layer = layer

        # Sync related combo boxes
        if not self.init:
            syncComboBoxes(self.dockwidget.profile_creation_axis_layer_comboBox, self.axisLayerComboBoxes, self.axis_layer)

    def profile_creation_dems_listView_itemChanged(self, item):
        """Handles modification of profile creation dem list item"""

        # Add or remove corresponding DEM

        if item.checkState():

            ## Add corresponding layer to list

            for layer in self.demLayers:
                if layer.name() == item.text():
                    if layer not in self.demList:
                        self.demList.append(layer)

        else:

            ## Remove corresponding layer from list

            for layer in self.demLayers:
                if layer.name() == item.text():
                    if layer in self.demList:
                        self.demList.remove(layer)

        # Reorder list

        newList = []

        for layer in self.demLayers:
            if layer in self.demList:
                newList.append(layer)

        self.demList = newList

        # Sync related list views

        if not self.init:
            syncListViews(self.dockwidget.profile_creation_dems_listView, self.demListViews, self.demList)

    def profile_creation_vertical_exaggeration_spinBox_changed(self):
        """Handles modification of profile creation vertical exaggeration"""

        # Update value

        self.vertical_exaggeration = self.dockwidget.profile_creation_vertical_exaggeration_spinBox.value()

    def profile_creation_grid_interval_doubleSpinBox_changed(self):
        """Handles modification of profile creation grid interval"""

        # Update value

        self.grid_interval = self.dockwidget.profile_creation_grid_interval_doubleSpinBox.value()

    def profile_creation_intersect_layer_comboBox_changed(self):
        """Handles modification of the profile creation intersect layer combo box"""

        layerName = self.dockwidget.profile_creation_intersect_layer_comboBox.currentText()

        # Modify the value

        if not self.init:

            if self.dockwidget.profile_creation_intersect_layer_comboBox.currentIndex() == 0:
                self.intersect_layer = None

            else:

                for layer in self.polygonLayers:
                    if layer.name() == layerName:
                        self.intersect_layer = layer

        # Hide or show ID field combo box accordingly

        self.dockwidget.profile_creation_intersect_id_field_comboBox.setVisible(self.intersect_layer != None)
        self.dockwidget.profile_creation_intersect_id_field_label.setVisible(self.intersect_layer != None)

        self.dockwidget.profile_creation_intersect_filter_expression_widget.setVisible(self.intersect_layer != None)
        self.dockwidget.profile_creation_intersect_filter_expression_label.setVisible(self.intersect_layer != None)

        # Change items in the ID fields combo box

        fieldComboBox = self.dockwidget.profile_creation_intersect_id_field_comboBox

        ## List fields in the source layer


        fieldComboBox.clear()

        if self.intersect_layer == None:

            self.profile_creation_intersect_id_field = ''

        else:

            self.intersectLayerFields = list(self.intersect_layer.fields())
            self.intersectLayerFieldNames = listFieldNames(self.intersectLayerFields)

            ## Add items

            fieldComboBox.clear()
            if self.intersectLayerFieldNames != None and len(self.intersectLayerFieldNames) > 0:
                fieldComboBox.addItems(self.intersectLayerFieldNames)

            ## Set default value

            fieldComboBox.setCurrentIndex(0)

        # Change filter expression context

        self.dockwidget.profile_creation_intersect_filter_expression_widget.setLayer(self.intersect_layer)

    def profile_creation_intersect_id_field_comboBox_changed(self):
        """Handles modification of the profile creation ID field combo box"""

        fieldName = self.dockwidget.profile_creation_intersect_id_field_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for field in self.intersectLayerFields:
                if field.name() == fieldName:
                    self.profile_creation_intersect_id_field = field.name()

    def profile_creation_grid_checkBox_changed(self):
        """Handles modification of profile creation grid creation boolean"""

        # Modifies the value

        self.profile_creation_grid = self.dockwidget.profile_creation_grid_checkBox.isChecked()

        # Hide or show interval spin box accordingly

        self.dockwidget.profile_creation_grid_interval_doubleSpinBox.setVisible(self.profile_creation_grid)
        self.dockwidget.profile_creation_grid_interval_label.setVisible(self.profile_creation_grid)

    def profile_creation_extremities_checkBox_changed(self):
        """Handles modification of profile creation extremities creation boolean"""

        # Modifies the value

        self.extremities = self.dockwidget.profile_creation_extremities_checkBox.isChecked()

        # Updates object projection checkbox

        self.dockwidget.object_projection_extremities_checkBox.setChecked(self.extremities)

    def profile_creation_checkParameters(self):
        """Check profile creation input parameters"""

        errors = 0

        # Check profile creation DEM layers list parameter

        if len(self.demList) < 0:
            self.dockwidget.profile_creation_dems_checkLabel.setText("Vous devez sélectionner au moins un MNT.")
            self.dockwidget.profile_creation_dems_checkLabel.setVisible(True)
            errors += 1

        else:

            self.dockwidget.profile_creation_dems_checkLabel.setVisible(False)

        # Check ID field parameter

        if (self.profile_creation_intersect_id_field == None or self.profile_creation_intersect_id_field == '') and self.intersect_layer != None:
            self.dockwidget.profile_creation_intersect_id_field_checkLabel.setText("Vous devez sélectionner un champ d'identification.")
            self.dockwidget.profile_creation_intersect_id_field_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.profile_creation_intersect_id_field_checkLabel.setVisible(False)

        # Check filter expression

        ## Check whether expression is valid

        if not self.dockwidget.profile_creation_intersect_filter_expression_widget.isValidExpression():
            self.dockwidget.profile_creation_intersect_filter_expression_checkLabel.setText("L'expression n'est pas valide.")
            self.dockwidget.profile_creation_intersect_filter_expression_checkLabel.setVisible(True)
            errors += 1

        ## Check whether expression matches any entities from the intersect layer

        elif self.intersect_layer != None:
            features = self.intersect_layer.getFeatures(self.dockwidget.profile_creation_intersect_filter_expression_widget.expression())

            empty = True
            for feature in features:
                empty = False
                break

            if empty:
                self.dockwidget.profile_creation_intersect_filter_expression_checkLabel.setText("Aucune entité de la couche d'intersection ne vérifie cette expression.")
                self.dockwidget.profile_creation_intersect_filter_expression_checkLabel.setVisible(True)
                errors += 1

            else:
                self.profile_creation_intersect_filter_expression = self.dockwidget.profile_creation_intersect_filter_expression_widget.expression()
                self.dockwidget.profile_creation_intersect_filter_expression_checkLabel.setVisible(False)

        else:
            self.profile_creation_intersect_filter_expression = self.dockwidget.profile_creation_intersect_filter_expression_widget.expression()
            self.dockwidget.profile_creation_intersect_filter_expression_checkLabel.setVisible(False)

        # Return boolean according to number of errors

        return (errors == 0)

    def profile_creation_run(self):
        """Handles clicking on the profile creation run button"""

        # Check parameters

        if self.profile_creation_checkParameters():

            # Block all push buttons

            self.setEnabledPushButtons(False)

            # Run algorithm
            
            self.dockwidget.progressBar.setValue(0)
            results = createProfiles(self.axis_layer, 
                                          self.demList, 
                                          self.vertical_exaggeration, 
                                          self.intersect_layer, 
                                          self.profile_creation_intersect_id_field, 
                                          self.profile_creation_intersect_filter_expression,
                                          self.extremities,
                                          self.dockwidget.progressBar)

            # Check results

            if self.extremities:

                if results == None or type(results) is not list or len(results) != 2:
                    debug_print("Error while creating profiles")
                    self.setEnabledPushButtons(True)
                    return
            else:

                if results == None:
                    debug_print("Error while creating profiles")
                    self.setEnabledPushButtons(True)
                    return

            if self.extremities:
                profileLayer = results[0]
                extremitiesLayer = results[1]
            else:
                profileLayer = results

            # Load new layers

            if not profileLayer.isValid():
                debug_print("Profile layer " + profileLayer.name() + " failed to load!")
                return
            else:
                QgsProject.instance().addMapLayer(profileLayer)

            if self.extremities:
                if not extremitiesLayer.isValid():
                    debug_print("Grid extremities layer failed to load!")
                    return
                else:
                    QgsProject.instance().addMapLayer(extremitiesLayer)

            # Create grid

            if self.profile_creation_grid:

                self.dockwidget.progressBar.setValue(0)
                results = createProfileGrid(profileLayer, self.axis_layer, self.vertical_exaggeration, self.grid_interval, self.extremities, self.dockwidget.progressBar)

                # Check results

                if self.extremities:

                    if results == None or type(results) is not list or len(results) != 2:
                        debug_print("Error while projecting objects")
                        self.setEnabledPushButtons(True)
                        return
                else:

                    if results == None:
                        debug_print("Error while creating profile grid")
                        self.setEnabledPushButtons(True)
                        return

                if self.extremities:
                    gridLayer = results[0]
                    extremitiesLayer = results[1]
                else:
                    gridLayer = results

                # Load new layers

                if not gridLayer.isValid():
                    debug_print("Profile grid layer " + gridLayer.name() + " failed to load!")
                    return
                else:
                    QgsProject.instance().addMapLayer(gridLayer)

                if self.extremities:
                    if not extremitiesLayer.isValid():
                        debug_print("Grid extremities layer failed to load!")
                        return
                    else:
                        QgsProject.instance().addMapLayer(extremitiesLayer)

            # Enable all push buttons

            self.setEnabledPushButtons(True)

    #--------------------------------------------------------------------------

    def initObjectProjectionWidget(self):
        """Initializes object projection interface"""

        # Handle altitude field combo box modification

        self.dockwidget.object_projection_altitude_field_comboBox.currentIndexChanged.connect(self.object_projection_altitude_field_comboBox_changed)

        # Handle object layer combo box modification

        self.dockwidget.object_projection_objects_layer_comboBox.currentIndexChanged.connect(self.object_projection_objects_layer_comboBox_changed)

        # Handle axis layer combo box modification

        self.dockwidget.object_projection_axis_layer_comboBox.currentIndexChanged.connect(self.object_projection_axis_layer_comboBox_changed)

        # Initialize max distance spin box

        spinBox = self.dockwidget.object_projection_distance_doubleSpinBox

        ## Set default value

        self.projection_distance = spinBox.value()

        ## Handle modification of max distance

        spinBox.valueChanged.connect(self.object_projection_distance_doubleSpinBox_changed)

        # Initialize vertical exaggeration spin box

        spinBox = self.dockwidget.object_projection_vertical_exaggeration_spinBox

        ## Set default value

        self.vertical_exaggeration = spinBox.value()

        ## Handle modification of vertical exaggeration

        spinBox.valueChanged.connect(self.object_projection_vertical_exaggeration_spinBox_changed)

        # Initialize grid creation checkbox

        checkBox = self.dockwidget.object_projection_grid_checkBox

        ## Hide interval spin box

        self.dockwidget.object_projection_grid_interval_doubleSpinBox.setVisible(self.object_projection_grid)
        self.dockwidget.object_projection_grid_interval_label.setVisible(self.profile_creation_grid)

        ## Handle modification of grid creation boolean

        checkBox.stateChanged.connect(self.object_projection_grid_checkBox_changed)

        # Initialize grid interval spin box

        spinBox = self.dockwidget.object_projection_grid_interval_doubleSpinBox

        ## Set default value

        self.grid_interval = spinBox.value()

        ## Handle modification of grid interval

        spinBox.valueChanged.connect(self.object_projection_grid_interval_doubleSpinBox_changed)

        # Initialize extremities creation checkbox

        checkBox = self.dockwidget.object_projection_extremities_checkBox

        ## Handle modification of extremities boolean

        checkBox.stateChanged.connect(self.object_projection_extremities_checkBox_changed)

        # Set up push button

        button = self.dockwidget.object_projection_pushButton

        button.clicked.connect(self.object_projection_run)

        # Hide all check labels

        self.dockwidget.object_projection_objects_layer_checkLabel.setVisible(False)
        self.dockwidget.object_projection_altitude_field_checkLabel.setVisible(False)
        self.dockwidget.object_projection_axis_layer_checkLabel.setVisible(False)

    #--------------------------------------------------------------------------

    def object_projection_objects_layer_comboBox_changed(self):
        """Handles modification of the object projection objects layer combo box"""

        layerName = self.dockwidget.object_projection_objects_layer_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for layer in self.polygonAndPointLayers:
                if layer.name() == layerName:
                    self.objects_layer = layer

        # Sync related combo boxes
        if not self.init:
            syncComboBoxes(self.dockwidget.object_projection_objects_layer_comboBox, self.objectsLayerComboBoxes, self.objects_layer)

        # Change items in the altitude fields combo box

        fieldComboBox = self.dockwidget.object_projection_altitude_field_comboBox

        ## List numeric fields in the source layer

        if self.objects_layer != None:
            self.objectLayerNumericFields = listNumericFields(self.objects_layer)
            self.objectLayerNumericFieldNames = listFieldNames(self.objectLayerNumericFields)

        ## Add items

        fieldComboBox.clear()
        if self.objectLayerNumericFieldNames != None and len(self.polygonAndPointLayerNames) > 0:
            fieldComboBox.addItems(self.objectLayerNumericFieldNames)

        ## Set default value

        fieldComboBox.setCurrentIndex(0)

    def object_projection_altitude_field_comboBox_changed(self):
        """Handles modification of the object projection altitude field combo box"""

        fieldName = self.dockwidget.object_projection_altitude_field_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for field in self.objectLayerNumericFields:
                if field.name() == fieldName:
                    self.altitude_field = field.name()

        # Sync related combo boxes
        if not self.init:
            syncComboBoxes(self.dockwidget.object_projection_altitude_field_comboBox, self.altitudeFieldComboBoxes, self.altitude_field)

    def object_projection_axis_layer_comboBox_changed(self):
        """Handles modification of the object projection axis layer combo box"""

        layerName = self.dockwidget.object_projection_axis_layer_comboBox.currentText()

        # Modify the value

        if not self.init:

            for layer in self.lineLayers:
                if layer.name() == layerName:
                    self.axis_layer = layer

        # Sync related combo boxes

        if not self.init:
            syncComboBoxes(self.dockwidget.object_projection_axis_layer_comboBox, self.axisLayerComboBoxes, self.axis_layer)

    def object_projection_distance_doubleSpinBox_changed(self):
        """Handles modification of object projection max distance"""

        # Update value

        self.projection_distance = self.dockwidget.object_projection_distance_doubleSpinBox.value()

    def object_projection_vertical_exaggeration_spinBox_changed(self):
        """Handles modification of object projection vertical exaggeration"""

        # Update value

        self.vertical_exaggeration = self.dockwidget.object_projection_vertical_exaggeration_spinBox.value()

    def object_projection_grid_checkBox_changed(self):
        """Handles modification of object projection grid creation boolean"""

        # Modifies the value

        self.object_projection_grid = self.dockwidget.object_projection_grid_checkBox.isChecked()

        # Hide or show interval spin box accordingly

        self.dockwidget.object_projection_grid_interval_doubleSpinBox.setVisible(self.object_projection_grid)
        self.dockwidget.object_projection_grid_interval_label.setVisible(self.object_projection_grid)

    def object_projection_grid_interval_doubleSpinBox_changed(self):
        """Handles modification of object projection grid interval"""

        # Update value

        self.grid_interval = self.dockwidget.object_projection_grid_interval_doubleSpinBox.value()

    def object_projection_extremities_checkBox_changed(self):
        """Handles modification of object projection extremities creation boolean"""

        # Modifies the value

        self.extremities = self.dockwidget.object_projection_extremities_checkBox.isChecked()

        # Updates object projection checkbox

        self.dockwidget.profile_creation_extremities_checkBox.setChecked(self.extremities)

    def object_projection_checkParameters(self):
        """Check object projection input parameters"""

        errors = 0

        # Check axis layer parameter

        if self.axis_layer == None:
            self.dockwidget.object_projection_axis_layer_checkLabel.setText("Vous devez sélectionner une couche d'axes de projection.")
            self.dockwidget.object_projection_axis_layer_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.object_projection_axis_layer_checkLabel.setVisible(False)

        # Check objects layer parameter

        if self.objects_layer == None:
            self.dockwidget.object_projection_objects_layer_checkLabel.setText("Vous devez sélectionner une couche d'objets.")
            self.dockwidget.object_projection_objects_layer_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.object_projection_objects_layer_checkLabel.setVisible(False)

        # Check altitude field parameter

        if self.altitude_field == None:
            self.dockwidget.object_projection_altitude_field_checkLabel.setText("Vous devez sélectionner un champ d'altitude.")
            self.dockwidget.object_projection_altitude_field_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.object_projection_altitude_field_checkLabel.setVisible(False)

        # Return boolean according to number of errors

        return (errors == 0)

    def object_projection_run(self):
        """Handles clicking on the object projection run button"""

        # Check parameters

        if self.object_projection_checkParameters():

            # Block all push buttons

            self.setEnabledPushButtons(False)

            # Run algorithm
            
            self.dockwidget.progressBar.setValue(0)
            
            # Create projection layer BEFORE calling projectObjects (workaround for QGIS 3.44)
            # Creating QgsVectorLayer inside projectObjects causes crashes in QGIS 3.44
            projectedPointsLayer = None
            try:
                # Use EPSG:32630 to match createProfileGrid default
                crs_authid = 'EPSG:32630'
                projectedPointsLayer = QgsVectorLayer('Point?crs=' + crs_authid, 'projected_points', 'memory')
                
                if projectedPointsLayer is None or not projectedPointsLayer.isValid():
                    debug_print("Error: Failed to create projection layer")
                    projectedPointsLayer = None
                        
            except Exception as e:
                debug_print("Error creating projection layer: " + str(e))
                projectedPointsLayer = None
            
            if projectedPointsLayer is None:
                debug_print("Error: Failed to create projection layer")
                self.setEnabledPushButtons(True)
                return
            
            results = projectObjects(self.objects_layer, 
                                     self.altitude_field, 
                                     self.axis_layer, 
                                     self.projection_distance, 
                                     self.vertical_exaggeration,
                                     self.extremities, 
                                     self.dockwidget.progressBar,
                                     projected_points_layer=projectedPointsLayer)

            # Check results

            if results == None:
                debug_print("Error: projectObjects returned None")
                self.setEnabledPushButtons(True)
                return
                
            if type(results) is not list:
                debug_print("Error: projectObjects did not return a list")
                self.setEnabledPushButtons(True)
                return

            if self.extremities:
                expectedNb = 3
            else:
                expectedNb = 2

            if len(results) != expectedNb:
                debug_print("Error while projecting objects - wrong number of results")
                self.setEnabledPushButtons(True)
                return

            # Load new layers

            objectsToProjectLayer = results[0]
            projectedPointsLayer = results[1]

            if projectedPointsLayer is None:
                debug_print("Error: projectedPointsLayer is None")
                self.setEnabledPushButtons(True)
                return

            if not projectedPointsLayer.isValid():
                debug_print("Projected points layer failed to load!")
                return
            else:
                QgsProject.instance().addMapLayer(projectedPointsLayer)

            if not objectsToProjectLayer.isValid():
                debug_print("Objects to project layer failed to load!")
                return
            else:
                QgsProject.instance().addMapLayer(objectsToProjectLayer)


            if self.extremities:
                extremitiesLayer = results[2]

                if not extremitiesLayer.isValid():
                    debug_print("Axis extremities layer failed to load!")
                    return
                else:
                    QgsProject.instance().addMapLayer(extremitiesLayer)

            # Create grid

            if self.object_projection_grid:

                self.dockwidget.progressBar.setValue(0)
                results = createProfileGrid(projectedPointsLayer, self.axis_layer, self.vertical_exaggeration, self.grid_interval, self.extremities, self.dockwidget.progressBar)

                # Check results

                if self.extremities:

                    if results == None or type(results) is not list or len(results) != 2:
                        debug_print("Error while projecting objects")
                        self.setEnabledPushButtons(True)
                        return
                else:

                    if results == None:
                        debug_print("Error while creating profile grid")
                        self.setEnabledPushButtons(True)
                        return

                if self.extremities:
                    gridLayer = results[0]
                    extremitiesLayer = results[1]
                else:
                    gridLayer = results

                # Load new layers

                if not gridLayer.isValid():
                    debug_print("Profile grid layer " + gridLayer.name() + " failed to load!")
                    return
                else:
                    QgsProject.instance().addMapLayer(gridLayer)

                if self.extremities:
                    if not extremitiesLayer.isValid():
                        debug_print("Grid extremities layer failed to load!")
                        return
                    else:
                        QgsProject.instance().addMapLayer(extremitiesLayer)

            # Enable all push buttons

            self.setEnabledPushButtons(True)

    #--------------------------------------------------------------------------

    def initLinkCreationWidget(self):
        """Initializes link creation interface"""

        # Handle modification of list of ID fields items

        self.dockwidget.link_creation_links_layer_fields_listView_model = QStandardItemModel()
        self.dockwidget.link_creation_links_layer_fields_listView.setModel(self.dockwidget.link_creation_links_layer_fields_listView_model)
        self.dockwidget.link_creation_links_layer_fields_listView_model.itemChanged.connect(self.link_creation_links_layer_fields_listView_itemChanged)

        # Handle links layer combo box modification

        self.dockwidget.link_creation_links_layer_comboBox.currentIndexChanged.connect(self.link_creation_links_layer_comboBox_changed)

        # Handle ID field combo box modification

        self.dockwidget.link_creation_objects_layer_field_comboBox.currentIndexChanged.connect(self.link_creation_objects_layer_field_comboBox_changed)

        # Handle object layer combo box modification

        self.dockwidget.link_creation_objects_layer_comboBox.currentIndexChanged.connect(self.link_creation_objects_layer_comboBox_changed)

        # Set up push button

        button = self.dockwidget.link_creation_pushButton

        button.clicked.connect(self.link_creation_run)

        # Hide all check labels

        self.dockwidget.link_creation_links_layer_checkLabel.setVisible(False)
        self.dockwidget.link_creation_objects_layer_checkLabel.setVisible(False)
        self.dockwidget.link_creation_links_layer_fields_checkLabel.setVisible(False)
        self.dockwidget.link_creation_objects_layer_field_checkLabel.setVisible(False)

    #--------------------------------------------------------------------------

    def link_creation_links_layer_comboBox_changed(self):
        """Handles modification of the links layer combo box"""

        layerName = self.dockwidget.link_creation_links_layer_comboBox.currentText()

        # Modify the value

        if not self.init:

            for layer in self.noGeomLayers:
                if layer.name() == layerName:
                    self.link_creation_links_layer = layer

        # Add fields to list

        ## List fields in the links layer

        if self.link_creation_links_layer != None:

            self.linksLayerFields = list(self.link_creation_links_layer.fields())
            self.link_creation_fieldList = listFieldNames(self.linksLayerFields)

        ## Add to list
        model = self.dockwidget.link_creation_links_layer_fields_listView.model()
        if self.link_creation_fieldList != None:

            for field in self.link_creation_fieldList:

                fieldItem = QStandardItem(field)
                fieldItem.setCheckable(True)
                model.appendRow(fieldItem)

            self.dockwidget.link_creation_links_layer_fields_listView.setModel(model)

    def link_creation_objects_layer_comboBox_changed(self):
        """Handles modification of the objects layer combo box"""

        layerName = self.dockwidget.link_creation_objects_layer_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for layer in self.polygonAndPointLayers:
                if layer.name() == layerName:
                    self.objects_layer = layer

        # Sync related combo boxes

        if not self.init:
            syncComboBoxes(self.dockwidget.link_creation_objects_layer_comboBox, self.objectsLayerComboBoxes, self.objects_layer)

        # Change items in the ID field combo box

        fieldComboBox = self.dockwidget.link_creation_objects_layer_field_comboBox

        ## List fields in the objects layer

        if self.objects_layer != None:

            self.objectLayerFields = list(self.objects_layer.fields())
            self.objectLayerFieldNames = listFieldNames(self.objectLayerFields)

        ## Add items

        fieldComboBox.clear()
        if self.objectLayerFieldNames != None and len(self.polygonAndPointLayerNames) > 0:
            fieldComboBox.addItems(self.objectLayerFieldNames)

        ## Set default value

        fieldComboBox.setCurrentIndex(0)

    def link_creation_links_layer_fields_listView_itemChanged(self, item):
        """Handles modification of field list item"""

        # Add or remove corresponding field

        if item.checkState():

            ## Add corresponding field to list

            for field in self.link_creation_fieldList:
                if field == item.text():
                    if field not in self.object_id_field_list:
                        self.object_id_field_list.append(field)

        else:

            ## Remove corresponding field from list

            for field in self.link_creation_fieldList:
                if field == item.text():
                    if field in self.object_id_field_list:
                        self.object_id_field_list.remove(field)

        # Reorder list

        newList = []

        for field in self.object_id_field_list:
            if field in self.object_id_field_list:
                newList.append(field)

        self.object_id_field_list = newList

        # Sync related list views

        if not self.init:
            syncListViews(self.dockwidget.link_creation_links_layer_fields_listView, self.objectIdFieldListViews, self.object_id_field_list)

    def link_creation_objects_layer_field_comboBox_changed(self):
        """Handles modification of the objects layer ID field combo box"""

        fieldName = self.dockwidget.link_creation_objects_layer_field_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for field in self.objectLayerFieldNames:
                if field == fieldName:
                    self.objects_id_field = field

        # Sync related combo boxes

        if not self.init:
            syncComboBoxes(self.dockwidget.link_creation_objects_layer_field_comboBox, self.objectsIdFieldComboBoxes, self.objects_id_field)

    def link_creation_checkParameters(self):
        """Check link creation input parameters"""

        errors = 0

        # Check links layer parameter

        if self.link_creation_links_layer == None:
            self.dockwidget.link_creation_links_layer_checkLabel.setText("Vous devez sélectionner une couche de liens.")
            self.dockwidget.link_creation_links_layer_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.link_creation_links_layer_checkLabel.setVisible(False)

        # Check list of links layer ID field parameter

        if len(self.object_id_field_list) != 2:
            self.dockwidget.link_creation_links_layer_fields_checkLabel.setText("Vous devez sélectionner deux champs d'identification des objets.")
            self.dockwidget.link_creation_links_layer_fields_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.link_creation_links_layer_fields_checkLabel.setVisible(False)

        # Check objects layer parameter

        if self.objects_layer == None:
            self.dockwidget.link_creation_objects_layer_checkLabel.setText("Vous devez sélectionner une couche d'objets.")
            self.dockwidget.link_creation_objects_layer_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.link_creation_objects_layer_checkLabel.setVisible(False)

        # Check objects layer ID field parameter

        if self.objects_id_field == None:
            self.dockwidget.link_creation_objects_layer_field_checkLabel.setText("Vous devez sélectionner un champ d'identification des objets.")
            self.dockwidget.link_creation_objects_layer_field_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.link_creation_objects_layer_field_checkLabel.setVisible(False)

        # Return boolean according to number of errors

        return (errors == 0)

    def link_creation_run(self):
        """Handles clicking on the link creation run button"""

        # Check parameters

        if self.link_creation_checkParameters():

            # Block all push buttons

            self.setEnabledPushButtons(False)

            # Run algorithm
            
            self.dockwidget.progressBar.setValue(0)
            linkLayer = createLinks(self.link_creation_links_layer, 
                                    self.objects_layer, 
                                    self.object_id_field_list, 
                                    self.objects_id_field, 
                                    self.dockwidget.progressBar)

            # Check results

            if linkLayer == None:
                debug_print("Error while creating links")
                self.setEnabledPushButtons(True)
                return

            # Load new layer

            if not linkLayer.isValid():
                debug_print("Links layer failed to load!")
                return
            else:
                QgsProject.instance().addMapLayer(linkLayer)

            # Enable all push buttons

            self.setEnabledPushButtons(True)

    #--------------------------------------------------------------------------

    def initLinkProjectionWidget(self):
        """Initializes link projection interface"""

        # Handle modification of list of ID fields items

        self.dockwidget.link_projection_links_layer_fields_listView_model = QStandardItemModel()
        self.dockwidget.link_projection_links_layer_fields_listView.setModel(self.dockwidget.link_projection_links_layer_fields_listView_model)
        self.dockwidget.link_projection_links_layer_fields_listView_model.itemChanged.connect(self.link_projection_links_layer_fields_listView_itemChanged)

        # Handle links layer combo box modification

        self.dockwidget.link_projection_links_layer_comboBox.currentIndexChanged.connect(self.link_projection_links_layer_comboBox_changed)

        # Handle ID field combo box modification

        self.dockwidget.link_projection_objects_layer_field_comboBox.currentIndexChanged.connect(self.link_projection_objects_layer_field_comboBox_changed)

        # Handle altitude field combo box modification

        self.dockwidget.link_projection_altitude_field_comboBox.currentIndexChanged.connect(self.link_projection_altitude_field_comboBox_changed)

        # Handle object layer combo box modification

        self.dockwidget.link_projection_objects_layer_comboBox.currentIndexChanged.connect(self.link_projection_objects_layer_comboBox_changed)

        # Handle axis layer combo box modification

        self.dockwidget.link_projection_axis_layer_comboBox.currentIndexChanged.connect(self.link_projection_axis_layer_comboBox_changed)

        # Initialize max distance spin box

        spinBox = self.dockwidget.link_projection_distance_doubleSpinBox

        ## Set default value

        self.projection_distance = spinBox.value()

        ## Handle modification of max distance

        spinBox.valueChanged.connect(self.link_projection_distance_doubleSpinBox_changed)

        # Initialize vertical exaggeration spin box

        spinBox = self.dockwidget.link_projection_vertical_exaggeration_spinBox

        ## Set default value

        self.vertical_exaggeration = spinBox.value()

        ## Handle modification of vertical exaggeration

        spinBox.valueChanged.connect(self.link_projection_vertical_exaggeration_spinBox_changed)

        # Set up push button

        button = self.dockwidget.link_projection_pushButton

        button.clicked.connect(self.link_projection_run)

        # Hide all check labels

        self.dockwidget.link_projection_links_layer_checkLabel.setVisible(False)
        self.dockwidget.link_projection_objects_layer_checkLabel.setVisible(False)
        self.dockwidget.link_projection_links_layer_fields_checkLabel.setVisible(False)
        self.dockwidget.link_projection_objects_layer_field_checkLabel.setVisible(False)
        self.dockwidget.link_projection_altitude_field_checkLabel.setVisible(False)
        self.dockwidget.link_projection_axis_layer_checkLabel.setVisible(False)

    #--------------------------------------------------------------------------

    def link_projection_links_layer_comboBox_changed(self):
        """Handles modification of the links layer combo box"""

        layerName = self.dockwidget.link_projection_links_layer_comboBox.currentText()

        # Modify the value

        if not self.init:

            for layer in self.lineLayers:
                if layer.name() == layerName:
                    self.link_projection_links_layer = layer

        # Add fields to list

        ## List fields in the links layer

        if self.link_projection_links_layer != None:

            self.linksLayerFields = list(self.link_projection_links_layer.fields())
            self.link_projection_fieldList = listFieldNames(self.linksLayerFields)

        ## Add to list
        model = self.dockwidget.link_projection_links_layer_fields_listView.model()
        model.clear()

        if self.link_projection_fieldList != None:

            for field in self.link_projection_fieldList:

                fieldItem = QStandardItem(field)
                fieldItem.setCheckable(True)
                model.appendRow(fieldItem)

            self.dockwidget.link_projection_links_layer_fields_listView.setModel(model)

    def link_projection_objects_layer_comboBox_changed(self):
        """Handles modification of the objects layer combo box"""

        layerName = self.dockwidget.link_projection_objects_layer_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for layer in self.polygonAndPointLayers:
                if layer.name() == layerName:
                    self.objects_layer = layer

        # Sync related combo boxes

        if not self.init:
            syncComboBoxes(self.dockwidget.link_projection_objects_layer_comboBox, self.objectsLayerComboBoxes, self.objects_layer)

        # Change items in the ID field combo box

        fieldComboBox = self.dockwidget.link_projection_objects_layer_field_comboBox

        ## List fields in the objects layer

        if self.objects_layer != None:

            self.objectLayerFields = list(self.objects_layer.fields())
            self.objectLayerFieldNames = listFieldNames(self.objectLayerFields)

        ## Add items

        fieldComboBox.clear()
        if self.objectLayerFieldNames != None and len(self.objectLayerFieldNames) > 0:
            fieldComboBox.addItems(self.objectLayerFieldNames)

        ## Set default value

        fieldComboBox.setCurrentIndex(0)

        # Change items in the altitude fields combo box

        fieldComboBox = self.dockwidget.link_projection_altitude_field_comboBox

        ## List numeric fields in the source layer

        if self.objects_layer != None:
            self.objectLayerNumericFields = listNumericFields(self.objects_layer)
            self.objectLayerNumericFieldNames = listFieldNames(self.objectLayerNumericFields)

        ## Add items

        fieldComboBox.clear()
        if self.objectLayerNumericFieldNames != None and len(self.objectLayerNumericFieldNames) > 0:
            fieldComboBox.addItems(self.objectLayerNumericFieldNames)

        ## Set default value

        fieldComboBox.setCurrentIndex(0)

    def link_projection_links_layer_fields_listView_itemChanged(self, item):
        """Handles modification of field list item"""

        # Add or remove corresponding field

        if item.checkState():

            ## Add corresponding field to list

            for field in self.link_projection_fieldList:
                if field == item.text():
                    if field not in self.object_id_field_list:
                        self.object_id_field_list.append(field)

        else:

            ## Remove corresponding field from list

            for field in self.link_projection_fieldList:
                if field == item.text():
                    if field in self.object_id_field_list:
                        self.object_id_field_list.remove(field)

        # Reorder list

        newList = []

        for field in self.object_id_field_list:
            if field in self.object_id_field_list:
                newList.append(field)

        self.object_id_field_list = newList

        # Sync related list views

        if not self.init:
            syncListViews(self.dockwidget.link_projection_links_layer_fields_listView, self.objectIdFieldListViews, self.object_id_field_list)

    def link_projection_objects_layer_field_comboBox_changed(self):
        """Handles modification of the objects layer ID field combo box"""

        fieldName = self.dockwidget.link_projection_objects_layer_field_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for field in self.objectLayerFieldNames:
                if field == fieldName:
                    self.objects_id_field = field

        # Sync related combo boxes

        if not self.init:
            syncComboBoxes(self.dockwidget.link_projection_objects_layer_field_comboBox, self.objectsIdFieldComboBoxes, self.objects_id_field)

    def link_projection_altitude_field_comboBox_changed(self):
        """Handles modification of the object projection altitude field combo box"""

        fieldName = self.dockwidget.link_projection_altitude_field_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for field in self.objectLayerNumericFields:
                if field.name() == fieldName:
                    self.altitude_field = field.name()

        # Sync related combo boxes
        if not self.init:
            syncComboBoxes(self.dockwidget.link_projection_altitude_field_comboBox, self.altitudeFieldComboBoxes, self.altitude_field)

    def link_projection_axis_layer_comboBox_changed(self):
        """Handles modification of the link projection axis layer combo box"""

        layerName = self.dockwidget.link_projection_axis_layer_comboBox.currentText()

        # Modify the value

        if not self.init:

            for layer in self.lineLayers:
                if layer.name() == layerName:
                    self.axis_layer = layer

        # Sync related combo boxes

        if not self.init:
            syncComboBoxes(self.dockwidget.link_projection_axis_layer_comboBox, self.axisLayerComboBoxes, self.axis_layer)

    def link_projection_distance_doubleSpinBox_changed(self):
        """Handles modification of link projection max distance"""

        # Update value

        self.projection_distance = self.dockwidget.link_projection_distance_doubleSpinBox.value()

    def link_projection_vertical_exaggeration_spinBox_changed(self):
        """Handles modification of link projection vertical exaggeration"""

        # Update value

        self.vertical_exaggeration = self.dockwidget.link_projection_vertical_exaggeration_spinBox.value()

    def link_projection_checkParameters(self):
        """Check link projection input parameters"""

        errors = 0

        # Check links layer parameter

        if self.link_projection_links_layer == None:
            self.dockwidget.link_projection_links_layer_checkLabel.setText("Vous devez sélectionner une couche de liens.")
            self.dockwidget.link_projection_links_layer_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.link_projection_links_layer_checkLabel.setVisible(False)

        # Check list of links layer ID field parameter

        if len(self.object_id_field_list) != 2:
            self.dockwidget.link_projection_links_layer_fields_checkLabel.setText("Vous devez sélectionner deux champs d'identification des objets.")
            self.dockwidget.link_projection_links_layer_fields_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.link_projection_links_layer_fields_checkLabel.setVisible(False)

        # Check objects layer parameter

        if self.objects_layer == None:
            self.dockwidget.link_projection_objects_layer_checkLabel.setText("Vous devez sélectionner une couche d'objets.")
            self.dockwidget.link_projection_objects_layer_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.link_projection_objects_layer_checkLabel.setVisible(False)

        # Check objects layer ID field parameter

        if self.objects_id_field == None:
            self.dockwidget.link_projection_objects_layer_field_checkLabel.setText("Vous devez sélectionner un champ d'identification des objets.")
            self.dockwidget.link_projection_objects_layer_field_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.link_projection_objects_layer_field_checkLabel.setVisible(False)

        # Check objects layer altitude field parameter

        if self.altitude_field == None:
            self.dockwidget.link_projection_altitude_field_checkLabel.setText("Vous devez sélectionner un champ d'altitude des objets.")
            self.dockwidget.link_projection_altitude_field_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.link_projection_altitude_field_checkLabel.setVisible(False)

        # Check axis layer parameter

        if self.axis_layer == None:
            self.dockwidget.link_projection_axis_layer_checkLabel.setText("Vous devez sélectionner une couche d'axes de projection.")
            self.dockwidget.link_projection_axis_layer_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.link_projection_axis_layer_checkLabel.setVisible(False)

        # Return boolean according to number of errors

        return (errors == 0)

    def link_projection_run(self):
        """Handles clicking on the link projection run button"""

        # Check parameters

        if self.link_projection_checkParameters():

            # Block all push buttons

            self.setEnabledPushButtons(False)

            # Run algorithm
            
            self.dockwidget.progressBar.setValue(0)
            linkLayer = projectLinks(self.link_projection_links_layer, 
                                     self.objects_layer, 
                                     self.object_id_field_list, 
                                     self.objects_id_field, 
                                     self.altitude_field, 
                                     self.axis_layer, 
                                     self.projection_distance, 
                                     self.vertical_exaggeration, 
                                     self.dockwidget.progressBar)

            # Check results

            if linkLayer == None:
                debug_print("Error while creating links")
                self.setEnabledPushButtons(True)
                return

            # Load new layer

            if not linkLayer.isValid():
                debug_print("Links layer failed to load!")
                return
            else:
                QgsProject.instance().addMapLayer(linkLayer)

            # Enable all push buttons

            self.setEnabledPushButtons(True)

    #--------------------------------------------------------------------------

    def initAxisFilteringWidget(self):
        """Initializes axis filtering interface"""

        # Handle filter combo box modification

        self.dockwidget.axis_filtering_filter_comboBox.currentIndexChanged.connect(self.axis_filtering_filter_comboBox_changed)

        # Handle axis ID field combo box modification

        self.dockwidget.axis_filtering_field_comboBox.currentIndexChanged.connect(self.axis_filtering_field_comboBox_changed)

        # Handle axis layer combo box modification

        self.dockwidget.axis_filtering_axis_layer_comboBox.currentIndexChanged.connect(self.axis_filtering_axis_layer_comboBox_changed)

        # Handle layer ID field combo box modification

        self.dockwidget.axis_filtering_id_field_comboBox.currentIndexChanged.connect(self.axis_filtering_id_field_comboBox_changed)

        # Handle modification of layer list items

        self.dockwidget.axis_filtering_layers_listView_model = QStandardItemModel()
        self.dockwidget.axis_filtering_layers_listView.setModel(self.dockwidget.axis_filtering_layers_listView_model)
        self.dockwidget.axis_filtering_layers_listView_model.itemChanged.connect(self.axis_filtering_layers_listView_itemChanged)

        # Set up push button

        button = self.dockwidget.axis_filtering_pushButton

        button.clicked.connect(self.axis_filtering_run)

        # Hide all check labels

        self.dockwidget.axis_filtering_axis_layer_checkLabel.setVisible(False)
        self.dockwidget.axis_filtering_field_checkLabel.setVisible(False)
        self.dockwidget.axis_filtering_layers_checkLabel.setVisible(False)
        self.dockwidget.axis_filtering_id_field_checkLabel.setVisible(False)

    #--------------------------------------------------------------------------

    def axis_filtering_axis_layer_comboBox_changed(self):
        """Handles modification of the axis filtering axis layer combo box"""

        layerName = self.dockwidget.axis_filtering_axis_layer_comboBox.currentText()

        # Modify the value

        if not self.init:

            for layer in self.lineLayers:
                if layer.name() == layerName:
                    self.axis_layer = layer

        # Sync related combo boxes

        if not self.init:
            syncComboBoxes(self.dockwidget.axis_filtering_axis_layer_comboBox, self.axisLayerComboBoxes, self.axis_layer)

        # Change items in the ID field combo box

        fieldComboBox = self.dockwidget.axis_filtering_field_comboBox

        ## List fields in the objects layer

        if self.axis_layer != None:
            self.axisLayerFields = list(self.axis_layer.fields())
            self.axisLayerFieldNames = listFieldNames(self.axisLayerFields)

        ## Add items

        fieldComboBox.clear()
        if self.axisLayerFieldNames != None and len(self.axisLayerFieldNames) > 0:
            fieldComboBox.addItems(self.axisLayerFieldNames)

        ## Set default value

        fieldComboBox.setCurrentIndex(0)

    def axis_filtering_field_comboBox_changed(self):
        """Handles modification of the axis ID field combo box"""

        fieldName = self.dockwidget.axis_filtering_field_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for field in self.axisLayerFieldNames:
                if field == fieldName:
                    self.axis_filtering_field = field

        ## Add items to filter

        comboBox = self.dockwidget.axis_filtering_filter_comboBox

        comboBox.clear()
        if self.axis_layer != None and self.axis_filtering_field != None:
            items = [NO_FILTER_TEXT]
            for axis in self.axis_layer.getFeatures():
                try: 
                    items.append(str(axis[self.axis_filtering_field]))
                except:
                    pass
            comboBox.addItems(items)

    def axis_filtering_filter_comboBox_changed(self):
        """Handles modification of axis filter"""

        self.axis_filtering_filter = self.dockwidget.axis_filtering_filter_comboBox.currentText()

        # Modifies the value

        if not self.init:

            if self.axis_filtering_filter == NO_FILTER_TEXT:
                self.axis_filtering_filter = ''

    def axis_filtering_layers_listView_itemChanged(self, item):
        """Handles modification of axis filtering layer list item"""

        # Add or remove corresponding layer

        if item.checkState():

            ## Add corresponding layer to list

            for layer in self.vectorLayers:
                if layer.name() == item.text():
                    if layer not in self.layerList:
                        self.layerList.append(layer)

        else:

            ## Remove corresponding layer from list

            for layer in self.vectorLayers:
                if layer.name() == item.text():
                    if layer in self.layerList:
                        self.layerList.remove(layer)

        # Reorder list

        newList = []

        for layer in self.vectorLayers:
            if layer in self.layerList:
                newList.append(layer)

        self.layerList = newList

        # Sync related list views

        if not self.init:
            syncListViews(self.dockwidget.axis_filtering_layers_listView, self.vectorLayerListViews, self.layerList)

        # Change items in the ID field combo box

        fieldComboBox = self.dockwidget.axis_filtering_id_field_comboBox

        ## Modify list of ID fields

        id_fields = []
        id_field_names = []
        if self.layerList != None and len(self.layerList) > 0:
            layer = self.layerList[0]
            for field in layer.fields():
                field_constant = True
                for layer2 in self.layerList:
                    has_same_field = False
                    for field2 in layer2.fields():
                        if field2.name() == field.name():
                            has_same_field = True
                    if not has_same_field:
                        field_constant = False
                        break
                if field_constant:
                    id_fields.append(field)
                    id_field_names.append(field.name())

        self.filteredLayerFields = id_fields
        self.filteredLayerFieldNames = id_field_names

        ## Add items

        fieldComboBox.clear()
        if self.filteredLayerFieldNames != None and len(self.filteredLayerFieldNames) > 0:
            fieldComboBox.addItems(self.filteredLayerFieldNames)

        ## Set default value

        if 'axis_id' in self.filteredLayerFieldNames:
            fieldComboBox.setCurrentIndex(self.filteredLayerFieldNames.index('axis_id'))
        else:
            fieldComboBox.setCurrentIndex(0)

    def axis_filtering_id_field_comboBox_changed(self):
        """Handles modification of the layer ID field combo box"""

        fieldName = self.dockwidget.axis_filtering_id_field_comboBox.currentText()

        # Modifies the value

        if not self.init:

            for field in self.filteredLayerFieldNames:
                if field == fieldName:
                    self.axis_id_field = field

        # Sync related combo boxes

        if not self.init:
            syncComboBoxes(self.dockwidget.axis_filtering_id_field_comboBox, self.axisIdFieldComboBoxes, self.axis_id_field)

    def axis_filtering_checkParameters(self):
        """Check axis filtering input parameters"""

        errors = 0

        # Check axis layer parameter

        if self.axis_layer == None:
            self.dockwidget.axis_filtering_axis_layer_checkLabel.setText("Vous devez sélectionner une couche d'axes de projection.")
            self.dockwidget.axis_filtering_axis_layer_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.axis_filtering_axis_layer_checkLabel.setVisible(False)

        # Check axis ID field parameter

        if self.axis_filtering_field == None:
            self.dockwidget.axis_filtering_field_checkLabel.setText("Vous devez sélectionner un champ d'identification des axes.")
            self.dockwidget.axis_filtering_field_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.axis_filtering_field_checkLabel.setVisible(False)

        # Check layers list parameter

        if len(self.layerList) < 1:
            self.dockwidget.axis_filtering_layers_checkLabel.setText("Vous devez sélectionner au moins une couche vecteur à filtrer.")
            self.dockwidget.axis_filtering_layers_checkLabel.setVisible(True)
            errors += 1

        else:

            self.dockwidget.axis_filtering_layers_checkLabel.setVisible(False)

        # Check layers ID field parameter

        if self.axis_id_field == None:
            self.dockwidget.axis_filtering_id_field_checkLabel.setText("Vous devez sélectionner un champ d'identification des objets.")
            self.dockwidget.axis_filtering_id_field_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.axis_filtering_id_field_checkLabel.setVisible(False)

        # Return boolean according to number of errors

        return (errors == 0)

    def axis_filtering_run(self):
        """Handles clicking on the axis filtering run button"""

        # Check parameters

        if self.axis_filtering_checkParameters():

            # Block all push buttons

            self.setEnabledPushButtons(False)

            # Run algorithm
            
            self.dockwidget.progressBar.setValue(0)
            success = filterByAxis(self.axis_layer, 
                                   self.axis_filtering_filter, 
                                   self.layerList, 
                                   self.axis_id_field, 
                                   self.dockwidget.progressBar)

            # Check results

            if not success:
                debug_print("Error while filtering layers by axis")
                self.setEnabledPushButtons(True)
                return

            # Enable all push buttons

            self.setEnabledPushButtons(True)

    #--------------------------------------------------------------------------

    def initAtlasConfiguringWidget(self):
        """Initializes atlas configuring interface"""

        # Initialize new layout name line edit

        lineEdit = self.dockwidget.atlas_configuring_layout_name_lineEdit

        ## Handle modification

        lineEdit.textChanged.connect(self.atlas_configuring_layout_name_lineEdit_changed)

        ## Hide

        lineEdit.setVisible(self.dockwidget.atlas_configuring_layout_name_comboBox.currentText() == NEW_LAYOUT_TEXT)
        self.dockwidget.atlas_configuring_layout_name_label.setVisible(self.dockwidget.atlas_configuring_layout_name_comboBox.currentText() == NEW_LAYOUT_TEXT)

        # Handle layout name combo box modification

        self.dockwidget.atlas_configuring_layout_name_comboBox.currentIndexChanged.connect(self.atlas_configuring_layout_name_comboBox_changed)

        # Handle axis layer combo box modification

        self.dockwidget.atlas_configuring_axis_layer_comboBox.currentIndexChanged.connect(self.atlas_configuring_axis_layer_comboBox_changed)

        # Handle layer ID field combo box modification

        self.dockwidget.atlas_configuring_id_field_comboBox.currentIndexChanged.connect(self.atlas_configuring_id_field_comboBox_changed)

        # Handle modification of layer list items

        self.dockwidget.atlas_configuring_layers_listView_model = QStandardItemModel()
        self.dockwidget.atlas_configuring_layers_listView.setModel(self.dockwidget.atlas_configuring_layers_listView_model)
        self.dockwidget.atlas_configuring_layers_listView_model.itemChanged.connect(self.atlas_configuring_layers_listView_itemChanged)

        # Set up push button

        button = self.dockwidget.atlas_configuring_pushButton

        button.clicked.connect(self.atlas_configuring_run)

        # Hide all check labels

        self.dockwidget.atlas_configuring_layout_name_checkLabel.setVisible(False)
        self.dockwidget.atlas_configuring_axis_layer_checkLabel.setVisible(False)
        self.dockwidget.atlas_configuring_layers_checkLabel.setVisible(False)
        self.dockwidget.atlas_configuring_id_field_checkLabel.setVisible(False)

    #--------------------------------------------------------------------------

    def atlas_configuring_layout_name_comboBox_changed(self):
        """Handles modification of the atlas configuring layout name combo box"""

        layoutName = self.dockwidget.atlas_configuring_layout_name_comboBox.currentText()

        # Modify the value

        if not self.init:

            if layoutName == NEW_LAYOUT_TEXT:
                self.layout_name = ''

            for layout in self.layouts:
                if layout.name() == layoutName:
                    self.layout_name = layoutName

        # Sync related combo boxes

        if not self.init:
            syncComboBoxes(self.dockwidget.atlas_configuring_layout_name_comboBox, self.layoutComboBoxes, self.layout_name)

        ## Show or hide new layout name field

        self.dockwidget.atlas_configuring_layout_name_label.setVisible(layoutName == NEW_LAYOUT_TEXT)
        self.dockwidget.atlas_configuring_layout_name_lineEdit.setVisible(layoutName == NEW_LAYOUT_TEXT)

    def atlas_configuring_layout_name_lineEdit_changed(self):
        """Handles modification of the atlas configuring layout name line edit"""

        # Modifies the value

        self.layout_name = self.dockwidget.atlas_configuring_layout_name_lineEdit.text().replace(' ', '')

    def atlas_configuring_axis_layer_comboBox_changed(self):
        """Handles modification of the atlas configuring axis layer combo box"""

        # Modify the value

        if not self.init:

            layerName = self.dockwidget.atlas_configuring_axis_layer_comboBox.currentText()

            for layer in self.lineLayers:
                if layer.name() == layerName:
                    self.axis_layer = layer

        # Sync related combo boxes

        if not self.init:
            syncComboBoxes(self.dockwidget.atlas_configuring_axis_layer_comboBox, self.axisLayerComboBoxes, self.axis_layer)
    
    def atlas_configuring_layers_listView_itemChanged(self, item):
        """Handles modification of atlas configuring layer list item"""

        # Add or remove corresponding layer

        if item.checkState():

            ## Add corresponding layer to list

            for layer in self.vectorLayers:
                if layer.name() == item.text():
                    if layer not in self.layerList:
                        self.layerList.append(layer)

        else:

            ## Remove corresponding layer from list

            for layer in self.vectorLayers:
                if layer.name() == item.text():
                    if layer in self.layerList:
                        self.layerList.remove(layer)

        # Reorder list

        newList = []

        for layer in self.vectorLayers:
            if layer in self.layerList:
                newList.append(layer)

        self.layerList = newList

        # Sync related list views

        if not self.init:
            syncListViews(self.dockwidget.atlas_configuring_layers_listView, self.vectorLayerListViews, self.layerList)

        # Change items in the ID field combo box

        fieldComboBox = self.dockwidget.atlas_configuring_id_field_comboBox

        ## Modify list of ID fields

        id_fields = []
        id_field_names = []
        if self.layerList != None and len(self.layerList) > 0:
            layer = self.layerList[0]
            for field in layer.fields():
                field_constant = True
                for layer2 in self.layerList:
                    has_same_field = False
                    for field2 in layer2.fields():
                        if field2.name() == field.name():
                            has_same_field = True
                    if not has_same_field:
                        field_constant = False
                        break
                if field_constant:
                    id_fields.append(field)
                    id_field_names.append(field.name())

        self.filteredLayerFields = id_fields
        self.filteredLayerFieldNames = id_field_names

        ## Add items

        fieldComboBox.clear()
        if self.filteredLayerFieldNames != None and len(self.filteredLayerFieldNames) > 0:
            fieldComboBox.addItems(self.filteredLayerFieldNames)

        ## Set default value

        if 'axis_id' in self.filteredLayerFieldNames:
            fieldComboBox.setCurrentIndex(self.filteredLayerFieldNames.index('axis_id'))
        else:
            fieldComboBox.setCurrentIndex(0)

    def atlas_configuring_id_field_comboBox_changed(self):
        """Handles modification of the ID field combo box"""

        # Modifies the value

        if not self.init:

            fieldName = self.dockwidget.atlas_configuring_id_field_comboBox.currentText()

            for field in self.filteredLayerFieldNames:
                if field == fieldName:
                    self.axis_id_field = field

        # Sync related combo boxes

        if not self.init:
            syncComboBoxes(self.dockwidget.atlas_configuring_id_field_comboBox, self.axisIdFieldComboBoxes, self.axis_id_field)

    def atlas_configuring_checkParameters(self):
        """Check atlas configuring input parameters"""

        errors = 0

        # Check layout name parameter

        if self.layout_name == None:
            self.dockwidget.atlas_configuring_layout_name_checkLabel.setText("Vous devez sélectionner une mise en page.")
            self.dockwidget.atlas_configuring_layout_name_checkLabel.setVisible(True)
            errors += 1

        elif self.layout_name == '':
            self.dockwidget.atlas_configuring_layout_name_checkLabel.setText("Vous devez entrer un nom pour la nouvelle mise en page.")
            self.dockwidget.atlas_configuring_layout_name_checkLabel.setVisible(True)
            errors += 1

        elif type(self.layout_name) is not str:
            try:
                self.layout_name = self.layout_name.name()
            except:
                self.dockwidget.atlas_configuring_layout_name_checkLabel.setText("Vous devez sélectionner une mise en page.")
                self.dockwidget.atlas_configuring_layout_name_checkLabel.setVisible(True)
                errors += 1

        else:
            self.dockwidget.atlas_configuring_layout_name_checkLabel.setVisible(False)

        # Check axis layer parameter

        if self.axis_layer == None:
            self.dockwidget.atlas_configuring_axis_layer_checkLabel.setText("Vous devez sélectionner une couche d'axes de projection.")
            self.dockwidget.atlas_configuring_axis_layer_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.atlas_configuring_axis_layer_checkLabel.setVisible(False)

        # Check layers list parameter

        if len(self.layerList) < 0:
            self.dockwidget.atlas_configuring_layers_checkLabel.setText("Vous devez sélectionner au moins une couche vecteur dépendant de l'atlas.")
            self.dockwidget.atlas_configuring_layers_checkLabel.setVisible(True)
            errors += 1

        else:

            self.dockwidget.atlas_configuring_layers_checkLabel.setVisible(False)

        # Check layers ID field parameter

        if self.axis_id_field == None:
            self.dockwidget.atlas_configuring_id_field_checkLabel.setText("Vous devez sélectionner un champ d'identification des axes.")
            self.dockwidget.atlas_configuring_id_field_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.atlas_configuring_id_field_checkLabel.setVisible(False)

        # Return boolean according to number of errors

        return (errors == 0)

    def atlas_configuring_run(self):
        """Handles clicking on the atlas configuring run button"""

        # Check parameters

        if self.atlas_configuring_checkParameters():

            # Block all push buttons

            self.setEnabledPushButtons(False)

            # Run algorithm
            
            self.dockwidget.progressBar.setValue(0)
            success = configureAxisAtlas(self.layout_name, 
                                         self.axis_layer, 
                                         self.layerList, 
                                         self.axis_id_field, 
                                         self.dockwidget.progressBar)

            # Check results

            if not success:
                debug_print("Error while configuring axis atlas.")
                self.setEnabledPushButtons(True)
                return

            # Enable all push buttons

            self.setEnabledPushButtons(True)

    #--------------------------------------------------------------------------

    def initConnectionLinesCreationWidget(self):
        """Initializes connection lines creation interface"""

        # Initialize maps table

        tableWidget = self.dockwidget.connection_lines_creation_maps_tableWidget

        ## Set up headers

        tableWidget.setHorizontalHeaderLabels(["Carte", "Couche à relier"])
        tableWidget.horizontalHeader().setStretchLastSection(True)

        # Handle layout name combo box modification

        self.dockwidget.connection_lines_creation_layout_comboBox.currentIndexChanged.connect(self.connection_lines_creation_layout_comboBox_changed)

        # Set up push button

        button = self.dockwidget.connection_lines_creation_pushButton

        button.clicked.connect(self.connection_lines_creation_run)

        # Hide all check labels

        self.dockwidget.connection_lines_creation_layout_checkLabel.setVisible(False)
        self.dockwidget.connection_lines_creation_maps_checkLabel.setVisible(False)
        self.dockwidget.connection_lines_creation_id_field_checkLabel.setVisible(False)

    #--------------------------------------------------------------------------

    def connection_lines_creation_layout_comboBox_changed(self):
        """Handles modification of the connection lines creation layout combo box"""

        # Modify the value

        if not self.init:

            layoutName = self.dockwidget.connection_lines_creation_layout_comboBox.currentText()

            for layout in self.layouts:
                if layout.name() == layoutName:
                    self.layout_name = layout

        # Sync related combo boxes

        if not self.init:
            syncComboBoxes(self.dockwidget.connection_lines_creation_layout_comboBox, self.layoutComboBoxes, self.layout_name)

        # Add maps to table

        ## List maps in the layout

        self.maps = []
        self.mapNames = []

        self.connection_lines_creation_mapList = []
        self.connection_lines_creation_layerList = []

        if self.connection_lines_creation_layout != None:

            for item in self.connection_lines_creation_layout.items():
                if item.type() == QgsLayoutItemRegistry.LayoutMap:
                    self.maps.append(item)
                    self.mapNames.append(item.displayName())
        else:
            self.maps = []
            self.mapNames = []

        # Clear table

        self.dockwidget.connection_lines_creation_maps_tableWidget.clear()

        for mapName in self.mapNames:

            ## Add to table

            ### Add row at bottom of table

            tableWidget = self.dockwidget.connection_lines_creation_maps_tableWidget

            row = tableWidget.rowCount()

            tableWidget.insertRow(row)

            # Populate first column

            mapItem = QTableWidgetItem(mapName)
            #mapItem.setCheckable(True)
            mapItem.setFlags(QtCore.Qt.ItemIsUserCheckable)

            tableWidget.setItem(row, 0, mapItem)

            # Handle modification of first column

            tableWidget.itemChanged.connect(self.connection_lines_creation_maps_tableView_itemChanged)

            # Populate second column

            boxCell = QComboBox()
            boxCell.addItems(self.vectorLayerNames)
            boxCell.setCurrentIndex(0)

            tableWidget.setCellWidget(row, 1, boxCell)

            # Handle modification of second column

            boxCell.currentIndexChanged.connect(lambda: self.layerBoxCell_changed(boxCell.currentText()))

            # Select atlas coverage layer by default

            index = 0
            i = 0
            while i < len(self.vectorLayerNames):
                layerName = self.vectorLayerNames[i]
                if layerName == self.connection_lines_creation_layout.atlas().coverageLayer().name():
                    index = i
                i += 1

            boxCell.setCurrentIndex(index)

            tableWidget.setCurrentCell(row, 0)

    def connection_lines_creation_maps_tableView_itemChanged(self, item):
        """Handles modification of connection lines creation map list item"""

        # Add or remove corresponding map

        if item.checkState():

            ## Add corresponding map to list

            for aMap in self.maps:
                if aMap.displayName() == item.text():
                    exists = False
                    for item in self.connection_lines_creation_mapList:
                        if item['map'] == aMap:
                            exists = True
                    if not exists:
                        self.connection_lines_creation_mapList.append({'map': aMap, 'layer': ''})

        else:

            ## Remove corresponding map from list

            for aMap in self.maps:
                if aMap.displayName() == item.text():
                    for item in self.connection_lines_creation_mapList:
                        if item['map'] == aMap:
                            self.connection_lines_creation_mapList.remove(item)

    def layerBoxCell_changed(self, layer_name):
        """Handles modification of map layer"""

        # Get index of modified map

        tableWidget = self.dockwidget.connection_lines_creation_maps_tableWidget

        index = tableWidget.currentIndex().row()

        #print("row : " + str(index))

        # Get layer name

        #print("couche sélectionnée : " + layer_name)

        # Get layer from name

        layer = None
        for aLayer in self.vectorLayers:
            if aLayer.name() == layer_name:
                layer = aLayer

        if layer == None:
            debug_print('Error encountered while editing map layer')
            return

        # Edit map

        newMaps = []

        i = 0
        while i < len(self.connection_lines_creation_mapList):
            full_map = self.connection_lines_creation_mapList[i]
            if i != index:
                newMaps.append(full_map)
            else:
                newMaps.append({'map': full_map['map'], 'layer': layer})

            i += 1

        self.connection_lines_creation_mapList = newMaps

        # Edit list of layers

        if layer not in self.connection_lines_creation_layerList:
            self.connection_lines_creation_layerList.append(layer)

        # Change items in the ID field combo box

        fieldComboBox = self.dockwidget.connection_lines_creation_id_field_comboBox

        ## Modify list of ID fields

        id_fields = []
        id_field_names = []
        if self.connection_lines_creation_layerList != None and len(self.connection_lines_creation_layerList) > 0:
            layer = self.connection_lines_creation_layerList[0]
            for field in layer.fields():
                field_constant = True
                for layer2 in self.connection_lines_creation_layerList:
                    has_same_field = False
                    for field2 in layer2.fields():
                        if field2.name() == field.name():
                            has_same_field = True
                    if not has_same_field:
                        field_constant = False
                        break
                if field_constant:
                    id_fields.append(field)
                    id_field_names.append(field.name())

        self.filteredLayerFields = id_fields
        self.filteredLayerFieldNames = id_field_names

        ## Add items

        fieldComboBox.clear()
        if self.filteredLayerFieldNames != None and len(self.filteredLayerFieldNames) > 0:
            fieldComboBox.addItems(self.filteredLayerFieldNames)

        ## Set default value

        fieldComboBox.setCurrentIndex(0)

    def connection_lines_creation_id_field_comboBox_changed(self):
        """Handles modification of the ID field combo box"""

        # Modifies the value

        if not self.init:

            fieldName = self.dockwidget.connection_lines_creation_id_field_comboBox.currentText()

            for field in self.filteredLayerFieldNames:
                if field == fieldName:
                    self.connection_lines_creation_id_field = field

    def connection_lines_creation_checkParameters(self):
        """Check connection lines creation input parameters"""

        errors = 0

        # Check layout parameter

        if self.layout_name == None:
            self.dockwidget.connection_lines_creation_layout_checkLabel.setText("Vous devez sélectionner une mise en page.")
            self.dockwidget.connection_lines_creation_layout_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.connection_lines_creation_layout_checkLabel.setVisible(False)

        # Check maps list parameter

        if len(self.connection_lines_creation_mapList) < 2:
            self.dockwidget.connection_lines_creation_maps_checkLabel.setText("Vous devez sélectionner au moins deux cartes à relier.")
            self.dockwidget.connection_lines_creation_maps_checkLabel.setVisible(True)
            errors += 1

        else:

            for map_info in self.connection_lines_creation_mapList:
                if map_info['layer'] == None:
                    self.dockwidget.connection_lines_creation_maps_checkLabel.setText("Vous devez sélectionner une couche à relier pour chaque carte sélectionnée.")
                    self.dockwidget.connection_lines_creation_maps_checkLabel.setVisible(True)
                    errors += 1
                    mapError = True

            if not mapError:
                self.dockwidget.connection_lines_creation_maps_checkLabel.setVisible(False)

        # Check layers ID field parameter

        if self.connection_lines_creation_id_field == None:
            self.dockwidget.connection_lines_creation_id_field_checkLabel.setText("Vous devez sélectionner un champ d'identification.")
            self.dockwidget.connection_lines_creation_id_field_checkLabel.setVisible(True)
            errors += 1

        else:
            self.dockwidget.connection_lines_creation_id_field_checkLabel.setVisible(False)

        # Return boolean according to number of errors

        return (errors == 0)

    def connection_lines_creation_run(self):
        """Handles clicking on the connection lines creation run button"""

        # Check parameters

        if self.connection_lines_creation_checkParameters():

            # Block all push buttons

            self.setEnabledPushButtons(False)

            # List maps and layers separately

            maps = []
            layers = []

            for map_info in self.connection_lines_creation_mapList:
                maps.append(map_info['map'])
                layers.append([map_info['layer']])

            # Run algorithm

            self.dockwidget.progressBar.setValue(0)
            created_lines_ids = drawConnectionLines(self.layout_name, 
                                                    maps, 
                                                    layers, 
                                                    self.connection_lines_creation_id_field, 
                                                    self.dockwidget.progressBar)

            # Check results

            if created_lines_ids == None or created_lines_ids == []:
                debug_print("Error while creating connection lines.")
                self.setEnabledPushButtons(True)
                return

            # Enable all push buttons

            self.setEnabledPushButtons(True)

    def setValueToSelectedLayer(self, value, valueList, replace=False):
        """
        ***************************************************************************
        Sets value to selected layer if in valueList.

        PARAMETERS:
        * value : value to update | object
        * valueList : list of possible values | list
        * replace : allow replacement if given value is not None | boolean
        
        OUTPUTS:
        updated value | object

        *************************************************************************** 
        """

        debug_print("Starting function setValueToSelectedLayer.")

        """
        Check parameters
        """

        debug_print("Checking parameters...")

        # Check value list parameter

        if valueList is not list:
            debug_print("Invalid value list parameter : not a list")
            return value

        if len(valueList) < 1:
            debug_print("Invalid value list parameter : empty list")
            return value

        # Check replace parameter

        if replace is not bool:
            debug_print("Invalid replace parameter : not a boolean")
            return value

        """
        Get first suitable selected layer
        """

        debug_print("Getting first suitable selected layer...")

        sel = None
        if len(self.iface.layerTreeView().selectedLayers()) > 0:
            for selectedLayer in self.iface.layerTreeView().selectedLayers():
                if selectedLayer in valueList:
                    sel = selectedLayer
                    break

        """
        Update combobox value
        """

        debug_print("Updating combobox value...")

        if (replace or value == None) and sel != None:
            value = sel

        """
        Return combo box new value
        """

        debug_print("Combo box value successfully updated!")

        return value

            
#--------------------------------------------------------------------------
#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

#################
### FUNCTIONS ###
#################

def listFieldNames(fields):
    """
    ***************************************************************************
    Returns list of field names in alphabetical order.

    PARAMETERS:
    * fields : list of fields | list of instances of QgsField

    OUTPUTS:
    list of names | list of strings
   
    *************************************************************************** 
    """

    debug_print("Starting function listFieldNames.")

    """
    Check parameter
    """

    if type(fields) is not list:
        debug_print("Invalid fields parameter : not a list")
        return

    if len(fields) < 1:
        debug_print("Invalid fields parameter : empty list")
        return

    for field in fields:
        if field.__class__.__name__ != 'QgsField':
            debug_print("Invalid fields parameter : not a list of QgsField objects")
            return

    """
    List fields
    """

    fieldNames = []

    for field in fields:
        fieldNames.append(field.name())

    return sorted(fieldNames)

def listNumericFields(layer):
    """
    ***************************************************************************
    Returns list of numeric fields for the layer.

    PARAMETERS:
    * layer : vector layer | instance of QgsVectorLayer

    OUTPUTS:
    list of fields | list of instances of QgsField
   
    *************************************************************************** 
    """

    debug_print("Starting function listNumericFields.")

    """
    Check parameter
    """

    if layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid layer parameter")
        return

    """
    List fields
    """

    fields = []

    for field in layer.fields():
        if field.typeName().lower() in ['float', 'double', 'real']:
            fields.append(field)

    return fields

def layerNames(layers):
    """
    ***************************************************************************
    Returns list of vector layers names in alphabetical order.

    PARAMETERS:
    * layers : list of layers | list of instances of QgsVectorLayer or QgsRasterLayer

    OUTPUTS:
    list of names | list of strings
   
    *************************************************************************** 
    """

    debug_print("Starting function layerNames.")

    """
    Check parameter
    """

    if type(layers) is not list:
        debug_print("Invalid layers parameter")
        return

    for layer in layers:
        if layer.__class__.__name__ != 'QgsVectorLayer' and layer.__class__.__name__ != 'QgsRasterLayer':
            debug_print("Invalid layers parameter")
            return

    """
    List and sort names
    """

    names = []

    for layer in layers:
        names.append(layer.name())

    return sorted(names)

def listVectorLayers():
    """
    ***************************************************************************
    Returns list of all vector layers in the current project.

    OUTPUTS:
    list of vector layers | list of instances of QgsVectorLayer
   
    *************************************************************************** 
    """

    debug_print("Starting function listVectorLayers.")

    vectorLayers = []

    for layer in QgsProject.instance().mapLayers():
        layer = QgsProject.instance().mapLayer(layer)
        if layer.__class__.__name__ == 'QgsVectorLayer':
            vectorLayers.append(layer)

    return vectorLayers

def listRasterLayers():
    """
    ***************************************************************************
    Returns list of all raster layers in the current project.

    OUTPUTS:
    list of raster layers | list of instances of QgsRasterLayer
   
    *************************************************************************** 
    """

    debug_print("Starting function listRasterLayers.")

    rasterLayers = []

    for layer in QgsProject.instance().mapLayers():
        layer = QgsProject.instance().mapLayer(layer)
        if layer.__class__.__name__ == 'QgsRasterLayer':
            rasterLayers.append(layer)

    return rasterLayers

def listNoGeomLayers():
    """
    ***************************************************************************
    Returns list of all vector layers with no geometries in the current project.

    OUTPUTS:
    list of vector layers | list of instances of QgsVectorLayer
   
    *************************************************************************** 
    """

    debug_print("Starting function listNoGeomLayers.")

    noGeomLayers = []

    layers = listVectorLayers()
    for layer in layers:
        if layer.geometryType() in [QgsWkbTypes.NullGeometry, QgsWkbTypes.UnknownGeometry]:
            noGeomLayers.append(layer)

    return noGeomLayers

def listPolygonLayers():
    """
    ***************************************************************************
    Returns list of all polygon vector layers in the current project.

    OUTPUTS:
    list of vector layers | list of instances of QgsVectorLayer
   
    *************************************************************************** 
    """

    debug_print("Starting function listPolygonLayers.")

    polygonLayers = []

    layers = listVectorLayers()
    for layer in layers:
        if layer.geometryType() == QgsWkbTypes.PolygonGeometry:
            polygonLayers.append(layer)

    return polygonLayers

def listLineLayers():
    """
    ***************************************************************************
    Returns list of all line vector layers in the current project.

    OUTPUTS:
    list of vector layers | list of instances of QgsVectorLayer
   
    *************************************************************************** 
    """

    debug_print("Starting function listLineLayers.")

    lineLayers = []

    layers = listVectorLayers()
    for layer in layers:
        if layer.geometryType() == QgsWkbTypes.LineGeometry:
            lineLayers.append(layer)

    return lineLayers

def listPointLayers():
    """
    ***************************************************************************
    Returns list of all point vector layers in the current project.

    OUTPUTS:
    list of vector layers | list of instances of QgsVectorLayer
   
    *************************************************************************** 
    """

    debug_print("Starting function listPointLayers.")

    pointLayers = []

    layers = listVectorLayers()
    for layer in layers:
        if layer.geometryType() == QgsWkbTypes.PointGeometry:
            pointLayers.append(layer)

    return pointLayers

def listLayouts():
    """
    ***************************************************************************
    Returns list of all layouts in the current project.

    OUTPUTS:
    list of layouts | list of instances of QgsMasterLayoutInterface
   
    *************************************************************************** 
    """

    debug_print("Starting function listLayouts.")

    return QgsProject.instance().layoutManager().layouts()

def layoutNames(layouts):
    """
    ***************************************************************************
    Returns list of layout names in alphabetical order.

    PARAMETERS:
    * layouts : list of layouts | list of instances of QgsMasterLayoutInterface or QgsPrintLayout

    OUTPUTS:
    list of names | list of strings
   
    *************************************************************************** 
    """

    debug_print("Starting function layoutNames.")

    """
    Check parameter
    """

    if type(layouts) is not list:
        debug_print("Invalid layouts parameter")
        return

    for layout in layouts:
        if layout.__class__.__name__ != 'QgsMasterLayoutInterface' and layout.__class__.__name__ != 'QgsPrintLayout':
            debug_print("Invalid layouts parameter")
            return

    """
    List and sort names
    """

    names = []

    for layout in layouts:
        names.append(layout.name())

    return sorted(names)

def runProcessingAlg(alg_name, parameters):
    """
    ***************************************************************************
    Runs a processing algorithm and returns the result.

    PARAMETERS:
    * alg_name : name of algorithm to be run | string
    * parameters : input parameters | dict

    OUTPUTS:
    depends on algorithm
   
    *************************************************************************** 
    """

    debug_print("Starting function runProcessingAlg.")

    """
    Check parameters
    """

    # Check algorithm name parameter

    if type(alg_name) is not str:
        debug_print("Invalid algorithm name parameter")
        return
    else:
        found = None

        for algorithm in QgsApplication.processingRegistry().algorithms():
            if algorithm.id() == alg_name:
                found = True

        if found == None:
            debug_print("Invalid algorithm name parameter")
            return

    # Check parameters parameter

    if type(parameters) is not dict:
        debug_print("Invalid parameters parameter")
        return

    feedback = QgsProcessingFeedback()
    results = processing.run(alg_name, parameters, feedback=feedback)

    if 'OUTPUT' in results.keys():
        key = 'OUTPUT'
    elif 'TARGET_OUT_GRID' in results.keys():
        key = 'TARGET_OUT_GRID'
    elif 'INTERSECT' in results.keys():
        key = 'INTERSECT'
    return results[key]

def createDEM(topo_layer, altitude_field, extent, distance, filter_expression = '', aggregate_type = 0, interpolation_method = INTERPOLATION_BSPLINE, resolution=0.01, clipping = False, progress_bar = None):
    """
    ***************************************************************************
    Creates and returns a DEM raster layer.

    PARAMETERS:
    * topo_layer : source layer containing altitudes | instance of QgsVectorLayer class, either a Polygon or a Point vector layer
    * altitude_field : name of the field containing altitudes of features in the source layer | string
    * extent : extent of the output raster | either an instance of QgsVectorLayer class or a list of 4 floats as such : Xmin, Xmax, Ymin, Ymax
    * distance : distance between two data points to use for interpolation | float
    * filter_expression : expression to filter source layer before DEM generation | string
    * aggregate_type : aggregate function to use | either one of the AGGREGATE constant ints or one of the AGGREGATES dict key strings
    * interpolation_method : method of interpolation to be used | either one of the INTERPOLATION constant ints or one of the INTERPOLATIONS dict key strings
    * resolution : resolution of the output raster | float
    * clipping : indicates whether the output raster should be clipped with the polygon made of the Oriented Minimal Bounding Box (OMBB) of the extent vector layer, if any | boolean
    * progress_bar : progress bar to update | instance of QProgressBar
   
    OUTPUTS:
    DEM raster layer | instance of class QgsRasterLayer

    *************************************************************************** 
    """

    debug_print("Starting function createDEM.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check progress bar parameter
    
    if progress_bar != None and progress_bar.__class__.__name__ != 'QProgressBar':
        debug_print("Invalid progress bar parameter")
        return

    # Initiate progress bar

    if progress_bar != None:
        progress_bar_max = progress_bar.maximum()
        progress_bar.setMaximum(0)

    # Check source layer parameter

    if topo_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid topographic layer parameter : not a vector layer")
        return
    
    if topo_layer.geometryType() != QgsWkbTypes.PointGeometry and topo_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
        debug_print("Invalid topographic layer parameter : wrong type of geometry")
        return

    if topo_layer.featureCount() < 1:
        debug_print("Invalid topographic layer parameter : empty layer")
        return

    sourceLayer = topo_layer

    # Check altitude field parameter

    if type(altitude_field) is not str:
        debug_print("Invalid altitude field parameter : not a chain of characters")
        return

    altField = None

    for field in topo_layer.fields():
        if field.name() == altitude_field and field.typeName().lower() in ['float', 'double', 'real']:
            altField = altitude_field

    if altField == None :
        debug_print("Invalid altitude field parameter : field is not a number")
        return

    # Check extent parameter

    extentLayer = None

    if type(extent) is list:
        if len(extent) != 4:
            debug_print("Invalid extent parameter : list does not contain the right number of items")
            return
        else:
            for coord in extent:
                if type(coord) not in [int, long, float]:
                    debug_print("Invalid extent parameter : not a list of numbers")
                    return
            extent = ','.join(extent)

    elif extent.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid extent parameter : not a list or a vector layer")
        return

    else:
        extentLayer = extent
        ext = extentLayer.extent()
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        extent = "%f,%f,%f,%f" %(xmin, xmax, ymin, ymax)

    # Check distance parameter

    if type(distance) not in [int, long, float]:
        debug_print("Invalid distance parameter : not a number")
        return

    if distance <= 0:
        debug_print("Invalid distance parameter : negative number")
        return

    # Check filter expression parameter

    if type(filter_expression) is not str:
        debug_print("Invalid filter expression parameter : not a chain of characters")
        return

    # Check aggregate type parameter

    if type(aggregate_type) is not int or aggregate_type not in AGGREGATES.values():
        if aggregate_type.lower() in AGGREGATES.keys():
            aggregate_type = AGGREGATES[aggregate_type]
        else:
            debug_print("Invalid aggregate type parameter")
            return

    # Check interpolation method parameter

    if type(interpolation_method) is not int or interpolation_method not in INTERPOLATIONS.values():
        if interpolation_method in INTERPOLATIONS.keys():
            interpolation_method = INTERPOLATIONS[interpolation_method]
        else:
            debug_print("Invalid interpolation method parameter")
            return

    # Check resolution parameter

    if type(resolution) not in [int, long, float]:
        debug_print("Invalid resolution parameter : not a number")
        return

    # Check clipping parameter

    if type(clipping) is not bool:
        debug_print("Invalid clipping parameter : not a boolean")
        return

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(5)

    """
    Get current project info
    """

    projCrs = QgsProject.instance().crs().authid()

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(10)

    """
    Create regular points
    """

    debug_print("Creating regular points...")

    parameters = {
        'CRS': projCrs,
        'EXTENT': extent,
        'SPACING': distance,
        'INSET': 0,
        'IS_SPACING': True,
        'RANDOMIZE': False,
        'OUTPUT': 'memory:point_grid'
    }

    regularPointsLayer = runProcessingAlg('qgis:regularpoints', parameters)
    QgsProject.instance().addMapLayer(regularPointsLayer)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(20)

    """
    Create buffers
    """

    debug_print("Creating buffers...")

    parameters = {
        'DISSOLVE': False,
        'DISTANCE': distance,
        'END_CAP_STYLE': 0,
        'INPUT': regularPointsLayer,
        'JOIN_STYLE': 0, 
        'MITER_LIMIT' : 2,
        'SEGMENTS' : 5,
        'OUTPUT' : 'memory:buffers'
    }

    buffersLayer = runProcessingAlg('native:buffer', parameters)
    QgsProject.instance().addMapLayer(buffersLayer)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(30)

    """
    Filter source layer
    """

    if filter_expression != '':

        debug_print("Filtering source layer...")

        parameters = {
            'EXPRESSION': filter_expression,
            'INPUT': sourceLayer,
            'OUTPUT': 'memory:filterSource'
        }

        sourceLayer = runProcessingAlg('native:extractbyexpression', parameters)
        QgsProject.instance().addMapLayer(sourceLayer)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(40)

    """
    Populate buffers with altitude data aggregate
    """

    debug_print("Populating buffers with altitude data aggregate...")

    SUMMARIES = [2, 11, 6, 7, 12, 3]

    parameters = {
        'DISCARD_NONMATCHING': False,
        'INPUT': buffersLayer,
        'JOIN': sourceLayer,
        'JOIN_FIELDS' : [altField],
        'PREDICATE' : [0,1,4,5,6],
        'SUMMARIES' : [SUMMARIES[aggregate_type]],
        'OUTPUT' : 'memory:popbuffers'
    }

    populatedBuffersLayer = runProcessingAlg('qgis:joinbylocationsummary', parameters)
    QgsProject.instance().addMapLayer(populatedBuffersLayer)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(50)

    """
    Join point grid with buffers
    """
    
    debug_print("Joining point grid with buffers...")

    parameters = {
        'DISCARD_NONMATCHING': False,
        'INPUT': regularPointsLayer,
        'JOIN': populatedBuffersLayer,
        'JOIN_FIELDS' : [],
        'METHOD': 0,
        'PREDICATE' : [0,1,4,5,6],
        'OUTPUT' : 'memory:poppoints'
    }

    populatedRegularPointsLayer = runProcessingAlg('qgis:joinattributesbylocation', parameters)
    QgsProject.instance().addMapLayer(populatedRegularPointsLayer)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(70)

    """
    Calculate interpolation
    """

    debug_print("Running interpolation...")

    # If IDW or TIN, calculate number of output rows and columns

    if interpolation_method in [INTERPOLATION_IDW, INTERPOLATION_TIN]:

        extentList = extent.split(',')

        columns = int(float(extentList[2]) - float(extentList[0]) / resolution)
        rows = int(float(extentList[3]) - float(extentList[1]) / resolution)

        # Update progress bar

        if progress_bar != None:
            progress_bar.setValue(80)
        
    # Run interpolation algorithm

    ## Calculate name of future DEM layer

    if filter_expression == '':
        dem_name = "DEM"
    else:
        dem_name = "DEM " + filter_expression.replace('\'', '').replace('"', '')

    if interpolation_method == INTERPOLATION_IDW:

        # Run IDW interpolation algorithm

        parameters = {
            'COLUMNS': colums,
            'ROWS': rows,
            'DISTANCE_COEFFICIENT': 2,
            'EXTENT': extent,
            'INTERPOLATION_DATA': populatedRegularPointsLayer,
            'OUTPUT': 'memory:' + dem_name
        }

        dem = runProcessingAlg('qgis:idwinterpolation', parameters)

    elif interpolation_method == INTERPOLATION_TIN:

        # Run TIN interpolation algorithm

        parameters = {
            'COLUMNS': columns,
            'ROWS': rows,
            'METHOD': 0,
            'EXTENT': extent,
            'INTERPOLATION_DATA': populatedRegularPointsLayer,
            'OUTPUT': 'memory:' + dem_name
        }

        dem = runProcessingAlg('qgis:tininterpolation', parameters)

    else:

        path = tempfile.gettempdir() + "/points.shp"
        QgsVectorFileWriter.writeAsVectorFormat(populatedRegularPointsLayer, path, "utf-8", driverName = "ESRI Shapefile")

        newPoints = QgsVectorLayer(path, 'points', 'ogr')

        altField = newPoints.fields()[-1].name()

        # Run SAGA Multilevel b-spline interpolation algorithm

        parameters = {
            'EPSILON': 0.0001,
            'FIELD': altField,
            'LEVEL_MAX': 11,
            'METHOD': 0,
            'OUTPUT_EXTENT': extent,
            'SHAPES': path,
            'TARGET_OUT_GRID': tempfile.gettempdir() + "/dem.sdat",
            'TARGET_USER_FITS': 0,
            'TARGET_USER_SIZE': resolution
        }

        dem_path = runProcessingAlg('saga:multilevelbsplineinterpolation', parameters)
        
        dem = QgsRasterLayer(dem_path, dem_name)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(90)

    """
    Clip DEM
    """

    if clipping and extentLayer != None:

        debug_print("Clipping DEM...")

        # Create OMBB from extent layer

        parameters = {
            'INPUT': extentLayer,
            'FIELD': '',
            'OUTPUT': tempfile.gettempdir() + "/ombb.shp",
            'TYPE': 3
        }

        ombb = runProcessingAlg('qgis:minimumboundinggeometry', parameters)

        #print("ombb ok")

        # Clip DEM raster with OMBB

        parameters = {
            'ALPHA_BAND': True,
            'CROP_TO_CUTLINE': True,
            'DATA_TYPE': 5,
            'INPUT': dem,
            'KEEP_RESOLUTION': False,
            'MASK': ombb,
            'NODATA': None,
            'OPTIONS': '',
            'OUTPUT': tempfile.gettempdir() + "/dem.tif"
        }

        dem_path = runProcessingAlg('gdal:cliprasterbymasklayer', parameters)
        
        dem = QgsRasterLayer(dem_path, dem_name)

        # Update progress bar

        if progress_bar != None:
            progress_bar.setValue(95)

    """
    Return DEM
    """

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(100)

    debug_print("DEM successfully created!")

    return dem

def correctDEMs(dems, rules, progress_bar = None):
    """
    ***************************************************************************
    Creates corrected DEMs from a list of DEMs and a list of stratigraphic rules.

    PARAMETERS:
    * dems : list of original DEMs | list of instances of QgsRasterLayer class
    * rules : list of rules, each with keys (parent) parent DEM index from the dems parameter, (child) child DEM index from the dems parameter, (position) constant defining which DEM is highest | list of dicts
    * progress_bar : progress bar to update | instance of QProgressBar
   
    OUTPUTS:
    list of DEM raster layers | list of instances of class QgsRasterLayer

    *************************************************************************** 
    """

    debug_print("Starting function correctDEMs.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check progress bar parameter
    
    if progress_bar != None and progress_bar.__class__.__name__ != 'QProgressBar':
        debug_print("Invalid progress bar parameter : not a progress bar")
        return

    # Initiate progress bar

    if progress_bar != None:
        progress_bar_max = progress_bar.maximum()
        progress_bar.setMaximum(0)

    # Check DEMs parameter

    if type(dems) is not list:
        debug_print("Invalid DEMs parameter : not a list")
        return

    if len(dems) < 1:
        debug_print("Invalid DEMs parameter : empty list")
        return

    for dem in dems:
        if dem.__class__.__name__ != 'QgsRasterLayer':
            debug_print("Invalid DEMs parameter : not a list of raster layers")
            return

    # Check rules parameter

    if type(rules) is not list:
        debug_print("Invalid rules parameter : not a list")
        return

    if len(rules) < 1:
        debug_print("Invalid rules parameter : empty list")
        return

    for rule in rules:
        if type(rule) is not dict:
            debug_print("Invalid rules parameter : not a dictionary")
            return

        for key in rule.keys():
            if key not in ['parent', 'child', 'position']:
                debug_print("Invalid rules parameter : wrong dictionary keys")
                return

        if type(rule['parent']) is not int or type(rule['child']) is not int or rule['position'] not in [PARENT_HIGHER, CHILD_HIGHER]:
            debug_print("Invalid rules parameter : wrong dictinary value types")
            return

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(10)

    """
    Apply rules
    """

    debug_print("Applying rules...")

    progressVal = int(85 / len(rules))

    correctDems = dems

    for rule in rules:

        # Get dictionary values and DEM layers

        parentLayer = correctDems[rule['parent']]
        childLayer = correctDems[rule['child']]
        position = rule['position']

        # Create corrected child DEM

        ## Calculate expression

        parentUrl = parentLayer.dataProvider().dataSourceUri()
        parentName = os.path.basename(parentUrl).replace('.tif', '').replace('.sdat', '')

        childUrl = childLayer.dataProvider().dataSourceUri()
        childName = os.path.basename(childUrl).replace('.tif', '').replace('.sdat', '')

        if position == PARENT_HIGHER:
            expression = '("' + childName + '@1" <= "' + parentName + '@1") * "' + childName + '@1" + ("' + childName + '@1" > "' + parentName + '@1") * "' + parentName + '@1"'
        else:
            expression = '("' + childName + '@1" >= "' + parentName + '@1") * "' + childName + '@1" + ("' + childName + '@1" < "' + parentName + '@1") * "' + parentName + '@1"'

        ## Run raster calculator

        parameters = {
            'LAYERS': [parentUrl, childUrl],
            'EXPRESSION': expression,
            'OUTPUT': tempfile.gettempdir() + '/' + str(uuid.uuid4()) + '.tif'
        }

        correctDEM_path = runProcessingAlg('qgis:rastercalculator', parameters)

        correctDEM = QgsRasterLayer(correctDEM_path, childLayer.name() + ' corr')

        # Replace child DEM in list

        newDems = []

        i = 0
        while i < len(correctDems):
            if i == rule['child']:
                newDems.append(correctDEM)
            else:
                newDems.append(correctDems[i])

            i += 1

        correctDems = newDems

        # Update progress bar

        if progress_bar != None:
            progress_bar.setValue(progress_bar.value() + progressVal)

    """
    Return list of corrected DEMs
    """

    debug_print("DEMs successfully corrected!")

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(100)

    return correctDems

def processDEMs(dems, gradient, interval, contour = False, contour_elevation_field = 'ELEV', hillshade = False, z_factor = 1, azimuth = 300, vertical_angle = 40, progress_bar = None):
    """
    ***************************************************************************
    Modifies the style of DEM layers and creates hillshade and contour lines for each.

    PARAMETERS:
    * dems : list of DEMs to create profiles from | list of instances of QgsRasterLayer class
    * gradient : color gradient to be used on DEMs | instance of QgsColorRamp
    * interval : interval between colors and contour lines | float
    * contour : indicates whether to create contour lines | boolean
    * contour_elevation_field : name of field containing elevation data in the contour layers | string
    * hillshade : indicates whether to create hillshade layers | boolean
    * z_factor : Z factor value for hillshade creation | float
    * azimuth : azimuth value for hillshade creation | float
    * vertical_angle : vertical angle value for hillshade creation | float
    * progress_bar : progress bar to update | instance of QProgressBar

    OUTPUTS:
    modified DEMs + contour lines layers + hillshade raster layers | list of (1) list of instances of class QgsRasterLayer, (2) list of instances of class QgsVectorLayer, (3) list of instances of class QgsRasterLayer

    *************************************************************************** 
    """

    debug_print("Starting function processDEMs.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check progress bar parameter
    
    if progress_bar != None and progress_bar.__class__.__name__ != 'QProgressBar':
        debug_print("Invalid progress bar parameter : not a progress bar")
        return

    # Initiate progress bar

    if progress_bar != None:
        progress_bar_max = progress_bar.maximum()
        progress_bar.setMaximum(0)

    # Check DEMs parameter

    if type(dems) is not list:
        debug_print("Invalid DEMs parameter : not a list")
        return

    if len(dems) < 1:
        debug_print("Invalid DEMs parameter : empty list")
        return

    for dem in dems:
        if dem.__class__.__name__ != 'QgsRasterLayer':
            debug_print("Invalid DEMs parameter : not a list of raster layers")
            return

    # Check gradient parameter

    if gradient.__class__.__name__ != 'QgsColorRamp' and gradient.__class__.__name__ != 'QgsGradientColorRamp':
        debug_print("Invalid gradient parameter : not a color ramp")
        return

    # Check interval parameter

    if type(interval) not in [int, long, float]:
        debug_print("Invalid interval parameter : not a number")
        return

    if interval <= 0:
        debug_print("Invalid interval parameter : negative number")
        return

    # Check contour parameter

    if type(contour) is not bool:
        debug_print("Invalid contour parameter : not a boolean")
        return

    # Check contour elevation field parameter

    if type(contour_elevation_field) is not str:
        debug_print("Invalid contour elevation field parameter : not a chain of characters")
        return

    # Check hillshade parameter

    if type(hillshade) is not bool:
        debug_print("Invalid hillshade parameter : not a boolean")
        return

    # Check Z factor parameter

    if type(z_factor) not in [int, long, float]:
        debug_print("Invalid Z factor parameter : not a number")
        return

    # Check azimuth parameter

    if type(azimuth) not in [int, long, float]:
        debug_print("Invalid azimuth parameter : not a number")
        return

    # Check vertical angle parameter

    if type(vertical_angle) not in [int, long, float]:
        debug_print("Invalid vertical angle parameter : not a number")
        return

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(10)

    """
    Calculate global minimum and maximum values
    """

    debug_print("Calculating global minimum and maximum values...")

    # Get min and max values from all DEMs

    minimum = None
    maximum = None

    for dem in dems:

        stats = dem.dataProvider().bandStatistics(1, QgsRasterBandStats.All, dem.extent(), 0)

        dem_min = stats.minimumValue
        dem_max = stats.maximumValue

        if minimum == None or dem_min < minimum:
            minimum = dem_min

        if maximum == None or dem_max > maximum:
            maximum = dem_max

    # Round min and max values according to range

    count_zeros = 0

    ## Find the number of leading zeros in the interval

    str_interval = str(interval)
    for char in str_interval:
        if char != '0' and char != '.':
            break
        elif char == '0':
            count_zeros += 1

    ## Round min and max values accordingly

    if count_zeros > 0:
        rnd = round(minimum, count_zeros)
        if rnd > minimum:
            minimum = rnd - 1/(10*count_zeros)
        else:
            minimum = rnd

        rnd = round(maximum, count_zeros)
        if rnd < maximum:
            maximum = rnd + 1/(10*count_zeros)
        else:
            maximum = rnd

    # Calculate number of classes

    classesNb = int((maximum - minimum) / interval + 1)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(20)

    """
    Create raster style
    """

    debug_print("Creating raster style...")

    fcn = QgsColorRampShader()
    fcn.setSourceColorRamp(gradient)
    fcn.setClassificationMode(QgsColorRampShader.EqualInterval)
    fcn.setMinimumValue(minimum)
    fcn.setMaximumValue(maximum)
    fcn.setClip(False)

    fcn.classifyColorRamp(classesNb)

    # Set interpolation to discrete if contour is true

    if contour:
        fcn.setColorRampType(QgsColorRampShader.Discrete)
    else:
        fcn.setColorRampType(QgsColorRampShader.Interpolated)

    shader = QgsRasterShader()
    shader.setRasterShaderFunction(fcn)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(30)

    """
    Apply raster style to listed DEMs
    """

    debug_print("Applying raster style to listed DEMs...")

    progressVal = int(65 / len(dems))

    contours = []
    hillshades = []

    for dem in dems:

        renderer = QgsSingleBandPseudoColorRenderer(dem.dataProvider(), 1, shader)
        dem.setRenderer(renderer)

        """
        Create contour lines
        """

        if contour:

            parameters = {
                'BAND': 1,
                'CREATE_3D': True,
                'FIELD_NAME': 'ELEV',
                'IGNORE_NODATA': False,
                'INPUT': dem,
                'INTERVAL': interval,
                'NODATA': 0,
                'OFFSET': 0,
                'OUTPUT': tempfile.gettempdir() + "/contour.shp"
            }

            contourLines_path = runProcessingAlg('gdal:contour', parameters)

            contourLines = QgsVectorLayer(contourLines_path, "Contours " + dem.name())

            contours.append(contourLines)

        """
        Create hillshade
        """

        if hillshade:

            parameters = {
                'AZIMUTH': azimuth,
                'INPUT': dem,
                'OUTPUT': tempfile.gettempdir() + "/hillshade.tif",
                'V_ANGLE': vertical_angle,
                'Z_FACTOR': z_factor
            }

            hillshadeLayer_path = runProcessingAlg('qgis:hillshade', parameters)

            hillshadeLayer = QgsRasterLayer(hillshadeLayer_path, "Hillshade " + dem.name())

            hillshades.append(hillshadeLayer)

        # Update progress bar

        if progress_bar != None:
            progress_bar.setValue(progress_bar.value() + progressVal)

    """
    Return lists
    """

    results = []

    if contour:
        results.append(contours)

    if hillshade:
        results.append(hillshades)

    if results == []:
        results = True

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(100)

    debug_print("DEMs successfully harmonized!")

    return results

def createProfiles(axis_layer, dems, vertical_exaggeration = 1, intersect_layer = None, intersect_id_field = '', filter_expression = '', extremities=False, progress_bar = None, crs=32630):
    """
    ***************************************************************************
    Creates profiles for each feature in the axis layer according to each DEM in list.

    PARAMETERS:
    * axis_layer : line layer containing axis | instance of QgsVectorLayer class, must be a Line vector layer
    * dems : list of DEMs to create profiles from | list of instances of QgsRasterLayer class
    * vertical_exaggeration : vertical exaggeration factor | float
    * intersect_layer : polygon layer to be intersected with the curve | instance of QgsVectorLayer class, must be a Polygon vector layer
    * intersect_id_field : name of ID field in the polygon layer to be intersected with the curve | string
    * filter_expression : expression to filter intersection layer before profile creation | string
    * extremities : indicates whether to create extremities for the axis | boolean
    * progress_bar : progress bar to update | instance of QProgressBar
    * crs : CRS number to use (equidistant) | int
    
    OUTPUTS:
    line layer containing profile curves | instance of QgsVectorLayer

    *************************************************************************** 
    """

    debug_print("Starting function createProfiles.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check progress bar parameter
    
    if progress_bar != None and progress_bar.__class__.__name__ != 'QProgressBar':
        debug_print("Invalid progress bar parameter : not a progress bar")
        return

    # Initiate progress bar

    if progress_bar != None:
        progress_bar_max = progress_bar.maximum()
        progress_bar.setMaximum(0)

    # Check axis layer parameter

    if axis_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid axis layer parameter : not a vector layer")
        return

    if axis_layer.geometryType() != QgsWkbTypes.LineGeometry:
        debug_print("Invalid axis layer parameter : wrong type of geometry")
        return

    if axis_layer.featureCount() < 1:
        debug_print("Invalid axis layer parameter : empty layer")
        return

    # Check DEMs parameter

    if type(dems) is not list:
        debug_print("Invalid DEMs parameter : not a list")
        return

    if len(dems) < 1:
        debug_print("Invalid DEMs parameter : empty list")
        return

    for dem in dems:
        if dem.__class__.__name__ != 'QgsRasterLayer':
            debug_print("Invalid DEMs parameter : not a list of raster layers")
            return

    # Check vertical exaggeration parameter

    if type(vertical_exaggeration) not in [int, long, float]:
        debug_print("Invalid vertical exaggeration parameter : not a number")
        return

    # Check intersect layer parameter

    if intersect_layer != None and intersect_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid intersect layer parameter : not a vector layer")
        return

    elif intersect_layer != None:
        if intersect_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            debug_print("Invalid intersect layer parameter : wrong type of geometry")
            return

        ## Check intersect id field parameter

        if type(intersect_id_field) is not str:
            debug_print("Invalid intersect id field parameter : not a chain of characters")
            return

        idField = None
        idFieldType = ''

        for field in intersect_layer.fields():
            if field.name() == intersect_id_field:
                idField = intersect_id_field
                ifFieldType = field.typeName()

        if idField == None :
            debug_print("Invalid intersect id field parameter : field does not exist")
            return

    else:
        idField = None
        idFieldType = ''

    # Check filter expression parameter

    if type(filter_expression) is not str:
        debug_print("Invalid filter expression parameter : not a chain of characters")
        return

    # Check extremities parameter

    if type(extremities) is not bool:
        debug_print("Invalid extremities parameter : not a boolean")
        return

    # Check CRS parameter

    if type(crs) is not int:
        try:
            crs = int(crs)
        except:
            debug_print("Invalid CRS parameter : not an int")
            return

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(10)

    """
    Duplicate axis layer
    """

    debug_print("Duplicating axis layer...")

    axisLayer = QgsVectorLayer('LineString?crs=' + str(QgsProject.instance().crs().authid()), 'axis_lines', 'memory')

    features = [feat for feat in axis_layer.getFeatures()]
    fields = axis_layer.dataProvider().fields().toList()

    axisLayer.dataProvider().addAttributes(fields)
    axisLayer.updateFields()
    axisLayer.dataProvider().addFeatures(features)

    """
    Create spatial index for line layer
    """

    debug_print("Creating spatial index for axis layer...")

    try:
        index = QgsSpatialIndex(axisLayer)
    except:
        debug_print("Spatial index creation failed.")
        pass

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(20)

    """
    Add axis id attribute to axis layer
    """

    debug_print("Adding axis id attribute to axis layer...")

    axis_id = False
    for aField in axis_layer.fields():
        if aField.name() == 'axis_id':
            axis_id = True
            break

    if not axis_id:
        axis_layer.dataProvider().addAttributes([QgsField('axis_id', QVariant.Int, len = 10)])
        axis_layer.updateFields()

        axis_layer.startEditing()
        for axis in axis_layer.getFeatures():
            axis['axis_id'] = axis.id()
            axis_layer.updateFeature(axis)
        axis_layer.commitChanges()

        axisLayer.dataProvider().addAttributes([QgsField('axis_id', QVariant.Int, len = 10)])
        axisLayer.updateFields()

        axisLayer.startEditing()

        for axis in axisLayer.getFeatures():
            axis['axis_id'] = axis.id()
            axisLayer.updateFeature(axis)
        axisLayer.commitChanges()

    #QgsProject.instance().addMapLayer(axisLayer)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(30)

    """
    Generate axis extremities if needed
    """

    if extremities:
        debug_print("Generating axis extremities...")

        # Create new point layer

        extremitiesLayer = QgsVectorLayer('Point?crs=' + str(QgsProject.instance().crs().authid()), 'axis_extremities', 'memory')

        # Add fields

        extremitiesLayer.dataProvider().addAttributes([QgsField('axis_id', QVariant.Int, len = 10)])
        extremitiesLayer.updateFields()

        # Add extremities

        newFeatures = []

        for axis in axisLayer.getFeatures():

            ## Get original point coordinates
            if len(axis.geometry().asMultiPolyline()[0]) > 1:
                start_X = axis.geometry().asMultiPolyline()[0][0].x()
                start_Y = axis.geometry().asMultiPolyline()[0][0].y()
                end_X = axis.geometry().asMultiPolyline()[0][1].x()
                end_Y = axis.geometry().asMultiPolyline()[0][1].y()

                ## Create extremity points

                startPoint = QgsFeature(extremitiesLayer.fields())
                startPoint.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(start_X, start_Y)))
                startPoint.setAttribute('axis_id', axis['axis_id'])

                newFeatures.append(startPoint)

                endPoint = QgsFeature(extremitiesLayer.fields())
                endPoint.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(end_X, end_Y)))
                endPoint.setAttribute('axis_id', axis['axis_id'])

                newFeatures.append(endPoint)
            
        extremitiesLayer.dataProvider().addFeatures(newFeatures)

    """
    Intersect with polygon layer
    """

    if intersect_layer != None:

        """
        Filter source layer
        """

        if filter_expression != '':

            debug_print("Filtering polygon layer...")

            parameters = {
                'EXPRESSION': filter_expression,
                'INPUT': intersect_layer,
                'OUTPUT': 'memory:filterSource'
            }

            intersect_layer = runProcessingAlg('native:extractbyexpression', parameters)

            #QgsProject.instance().addMapLayer(intersect_layer)

        # Update progress bar

        if progress_bar != None:
            progress_bar.setValue(35)

        debug_print("Intersecting with polygon layer...")

        # Intersect line layer with polygon layer

        # axisPath = tempfile.gettempdir() + "/axis.shp"
        # QgsVectorFileWriter.writeAsVectorFormat(axisLayer, axisPath, "utf-8", driverName = "ESRI Shapefile")

        # interPath = tempfile.gettempdir() + "/intersect.shp"
        # QgsVectorFileWriter.writeAsVectorFormat(intersect_layer, interPath, "utf-8", driverName = "ESRI Shapefile")

        # parameters = {
        #     'INTERSECT': tempfile.gettempdir() + "/intersection.shp",
        #     'LINES': axisPath,
        #     'METHOD': 1,
        #     'POLYGONS': interPath,
        #     'CRS': QgsProject.instance().crs().authid()
        # }

        # lineLayer_path = runProcessingAlg('saga:linepolygonintersection', parameters)

        # lineLayer = QgsVectorLayer(lineLayer_path, 'lines')

        parameters = {
            'INPUT': axisLayer,
            'OVERLAY': intersect_layer,
            'OUTPUT': 'memory:lines'
        }

        lineLayer = runProcessingAlg('native:clip', parameters)

        #QgsProject.instance().addMapLayer(lineLayer)

        # Join attributes from polygon layer

        parameters = {
            'DISCARD_NONMATCHING': False,
            'INPUT': lineLayer,
            'JOIN': intersect_layer,
            'JOIN_FIELDS' : [],
            'METHOD': 0,
            'PREDICATE' : [0,1,4,5,6],
            'OUTPUT' : 'memory:lines'
        }

        lineLayer = runProcessingAlg('qgis:joinattributesbylocation', parameters)

        if type(lineLayer) is str:
            lineLayer = QgsVectorLayer(lineLayer, 'lines', 'memory')

        #QgsProject.instance().addMapLayer(lineLayer)

    else:
        lineLayer = axisLayer

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(40)

    """
    Create spatial index for line layer
    """

    debug_print("Creating spatial index for line layer...")

    try:
        index = QgsSpatialIndex(lineLayer)
    except:
        debug_print("Spatial index creation failed.")
        pass

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(50)

    """
    Generate regular points along each line for each DEM
    """

    debug_print("Generating regular points along each line for each DEM...")

    progressVal = int(20 / 2*len(dems))

    projPoints = []

    for dem in dems:

        # Create regular points

        parameters = {
            'INPUT_RASTER': dem,
            'INPUT_VECTOR': lineLayer,
            'OUTPUT': 'memory:demaxispoints',
            'CRS': QgsProject.instance().crs().authid()
        }

        pointLayer = runProcessingAlg('qgis:generatepointspixelcentroidsalongline', parameters)

        if type(pointLayer) is str:
            pointLayer = QgsVectorLayer(pointLayer, 'demaxispoints', 'memory')

        # Populate points with raster value

        pointLayer.dataProvider().addAttributes([QgsField('altitude', QVariant.Double, len = 10, prec = 10), QgsField('axis_id', QVariant.Int, len = 10)])

        ## Add ID field if intersected with polygon layer

        if idField != None:
            if idFieldType.lower() == 'string':
                pointLayer.dataProvider().addAttributes([QgsField('intersect_id', QVariant.String, len = 100)])
            else:
                pointLayer.dataProvider().addAttributes([QgsField('intersect_id', QVariant.Int, len = 10)])

        pointLayer.updateFields()

        ## Get real line IDs

        line_ids = []
        for line in lineLayer.getFeatures():
            line_ids.append(line.id())

        pointLayer.startEditing()

        for point in pointLayer.getFeatures():
            point['line_id'] = line_ids[point['line_id']]

            for line in lineLayer.getFeatures():
                if line.id() == point['line_id']:
                    point['axis_id'] = line['axis_id']
                    break

            ident = dem.dataProvider().identify(point.geometry().asPoint(), QgsRaster.IdentifyFormatValue)
            if ident.isValid():
                point['altitude'] = ident.results()[1]

            pointLayer.updateFeature(point)

        pointLayer.commitChanges()

        #QgsProject.instance().addMapLayer(pointLayer)

        # Update progress bar

        if progress_bar != None:
            progress_bar.setValue(progress_bar.value() + progressVal)

        """
        Project points on their axis for each DEM
        """

        # Create new point layer

        projectedPointsLayer = QgsVectorLayer('Point?crs=EPSG:' + str(crs), 'projected_points', 'memory')

        # Add fields

        projectedPointsLayer.dataProvider().addAttributes([QgsField('axis_id', QVariant.Int, len = 10), QgsField('line_id', QVariant.Int, len = 10), QgsField('point_id',  QVariant.Int, len = 10), QgsField('altitude',  QVariant.Double, len = 10, prec = 10)])

        # ## Add ID field if intersected with polygon layer

        # if idField != None:
        #     if idFieldType.lower() == 'string':
        #         projectedPointsLayer.dataProvider().addAttributes([QgsField('intersect_id', QVariant.String, len = 100)])
        #     else:
        #         projectedPointsLayer.dataProvider().addAttributes([QgsField('intersect_id', QVariant.Int, len = 10)])

        projectedPointsLayer.updateFields()

        # Add projected points

        newFeatures = []

        for point in pointLayer.getFeatures():

            ## Get original point coordinates

            X = point.geometry().asQPointF().x()
            Y = point.geometry().asQPointF().y()

            ## Get axis geometry

            axis_geom = None

            for axis in axisLayer.getFeatures():
                if axis['axis_id'] == point['axis_id']:
                    axis_geom = axis.geometry()

            ## Calculate projected coordinates

            projX = axis_geom.lineLocatePoint(point.geometry())
            if type(point['altitude']) is float:
                projY = point['altitude'] * vertical_exaggeration
            else:
                projY = None

            ## Create projected point

            if projY != None:

                projectedPoint = QgsFeature(projectedPointsLayer.fields())
                projectedPoint.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(projX, projY)))
                projectedPoint.setAttribute('line_id', point['line_id'])
                projectedPoint.setAttribute('axis_id', point['axis_id'])
                projectedPoint.setAttribute('point_id', point['point_id'])
                projectedPoint.setAttribute('altitude', point['altitude'])

                # if idField != None:
                #     projectedPoint.setAttribute('intersect_id', point['intersect_id'])

                newFeatures.append(projectedPoint)
            
        projectedPointsLayer.dataProvider().addFeatures(newFeatures)

        #QgsProject.instance().addMapLayer(projectedPointsLayer)

        projPoints.append(projectedPointsLayer)

        # Update progress bar

        if progress_bar != None:
            progress_bar.setValue(progress_bar.value() + progressVal)

    """
    Connect points into profile curves
    """

    debug_print("Connecting points into profile curves...")

    # Create new line layer

    profileLayer = QgsVectorLayer('LineString?crs=EPSG:' + str(crs), 'profiles', 'memory')

    # Add fields

    profileLayer.dataProvider().addAttributes([QgsField('axis_id', QVariant.Int, len = 10), QgsField('line_id', QVariant.Int, len = 10), QgsField('DEM_name',  QVariant.String, len = 100), QgsField('DEM_id',  QVariant.String, len = 100)])
    
    ## Add ID field if intersected with polygon layer

    if idField != None:
        if idFieldType == 'String':
            profileLayer.dataProvider().addAttributes([QgsField('intersect_id', QVariant.String, len = 100)])
        else:
            profileLayer.dataProvider().addAttributes([QgsField('intersect_id', QVariant.Int, len = 10)])
    
    profileLayer.updateFields()

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(80)

    progressVal = int(15 / len(projPoints))

    # Add lines

    newFeatures = []

    i = 0
    while i < len(projPoints):

        ## Get DEM and corresponding projected points

        dem = dems[i]
        projPointLayer = projPoints[i]

        ## Create lines from projected points

        parameters = {
            'DATE_FORMAT': '',
            'GROUP_FIELD': 'line_id',
            'INPUT': projPointLayer,
            'ORDER_FIELD': 'point_id',
            'OUTPUT': 'memory:lines',
            'CRS': QgsProject.instance().crs().authid()
        }

        dem_lines = runProcessingAlg('qgis:pointstopath', parameters)

        if type(dem_lines) is str:
            dem_lines = QgsVectorLayer(dem_lines, 'lines', 'memory')

        ## Add lines to main line layer

        for dem_line in dem_lines.getFeatures():

            ## Get axis id

            axis_id = ''

            line_id = dem_line['line_id']
            for line in lineLayer.getFeatures():
                if line.id() == line_id:
                    axis_id = line['axis_id']
                    break

            ## Create line

            line = QgsFeature(profileLayer.fields())
            line.setGeometry(dem_line.geometry())
            line.setAttribute('axis_id', axis_id)
            line.setAttribute('line_id', line_id)
            line.setAttribute('DEM_id', dem.id())
            line.setAttribute('DEM_name', dem.name())

            if idField != None:
                inter_id = ''
                for aLine in lineLayer.getFeatures():
                    if aLine.id() == dem_line['line_id']:
                        theIdField = idField
                        for field in lineLayer.fields():
                            if field.name() == idField + '_2':
                                theIdField = field.name()
                                break
                        inter_id = aLine[theIdField]
                line.setAttribute('intersect_id', inter_id)

            newFeatures.append(line)

        # Update progress bar

        if progress_bar != None:
            progress_bar.setValue(progress_bar.value() + progressVal)

        i += 1
            
    profileLayer.dataProvider().addFeatures(newFeatures)

    """
    Return line layer
    """

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(100)

    debug_print("Profiles successfully created!")

    if extremities:
        return [profileLayer, extremitiesLayer]
    else:
        return profileLayer

def createGlobalProfileGrid(profile, vertical_exaggeration = 1, interval = 0.01, progress_bar = None, crs=32630):
    """
    ***************************************************************************
    Creates global grid for all profiles in a layer.

    PARAMETERS:
    * profile : profile line layer or projected points layer to create grid from | instance of QgsVectorLayer class
    * vertical_exaggeration : vertical exaggeration factor | float
    * interval : number with which to round min and max values | float
    * progress_bar : progress bar to update | instance of QProgressBar
    * crs : CRS number to use (equidistant) | int
    
    OUTPUTS:
    line layer containing grid | instance of QgsVectorLayer

    *************************************************************************** 
    """

    debug_print("Starting function createGlobalProfileGrid.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check progress bar parameter
    
    if progress_bar != None and progress_bar.__class__.__name__ != 'QProgressBar':
        debug_print("Invalid progress bar parameter : not a progress bar")
        return

    # Initiate progress bar

    if progress_bar != None:
        progress_bar_max = progress_bar.maximum()
        progress_bar.setMaximum(0)

    # Check profile parameter

    if profile.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid profiles parameter : not a vector layer")
        return

    if profile.geometryType() != QgsWkbTypes.LineGeometry and profile.geometryType() != QgsWkbTypes.PointGeometry:
        debug_print("Invalid profiles parameter : wrong type of geometry")
        return

    if profile.featureCount() < 1:
        debug_print("Invalid profiles parameter : empty layer")
        return

    # Check vertical exaggeration parameter

    if type(vertical_exaggeration) not in [int, long, float]:
        debug_print("Invalid vertical exaggeration parameter : not a number")
        return

    # Check interval parameter

    if type(interval) not in [int, long, float]:
        debug_print("Invalid interval parameter : not a number")
        return

    # Check CRS parameter

    if type(crs) is not int:
        try:
            crs = int(crs)
        except:
            debug_print("Invalid CRS parameter : not an int")
            return

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(10)

    """
    Get extent of profile layer
    """

    debug_print("Getting extent of profile layer...")

    ext = profile.extent()
    xmin = ext.xMinimum()
    xmax = ext.xMaximum()
    ymin = ext.yMinimum()
    ymax = ext.yMaximum()

    # Round min and max values according to range

    count_zeros = 0

    ## Find the number of leading zeros in the interval

    str_interval = str(interval)
    for char in str_interval:
        if char != '0' and char != '.':
            break
        elif char == '0':
            count_zeros += 1

    ## Round min and max values accordingly

    if count_zeros > 0:
        rnd = round(xmin, count_zeros)
        if rnd > xmin:
            xmin = rnd - 1/(10*count_zeros)
        else:
            xmin = rnd

        rnd = round(ymin, count_zeros)
        if rnd > ymin:
            ymin = rnd - 1/(10*count_zeros)
        else:
            ymin = rnd

        rnd = round(xmax, count_zeros)
        if rnd < xmax:
            xmax = rnd + 1/(10*count_zeros)
        else:
            xmax = rnd

        rnd = round(ymax, count_zeros)
        if rnd < ymax:
            ymax = rnd + 1/(10*count_zeros)
        else:
            ymax = rnd

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(50)

    """
    Create grid line layer
    """

    debug_print("Creating line layer...")

    # Create new line layer
    # Use the crs parameter (defaults to 32630)
    crs_to_use = 'EPSG:' + str(crs)
    debug_print("Creating profile_grid with CRS: " + crs_to_use)
    lineLayer = QgsVectorLayer('LineString?crs=' + crs_to_use, 'profile_grid', 'memory')

    # Add fields

    lineLayer.dataProvider().addAttributes([QgsField('value', QVariant.Double, len = 10, prec = 10), QgsField('min_value', QVariant.Double, len = 10, prec = 10), QgsField('max_value', QVariant.Double, len = 10, prec = 10), QgsField('direction', QVariant.String, len = 100)])

    lineLayer.updateFields()

    newFeatures = []

    # Create horizontal line

    line = QgsFeature(lineLayer.fields())
    line.setGeometry(QgsGeometry.fromPolylineXY([QgsPointXY(xmin, ymin), QgsPointXY(xmax, ymin)]))
    line.setAttribute('value', ymin / vertical_exaggeration)
    line.setAttribute('min_value', xmin)
    line.setAttribute('max_value', xmax)
    line.setAttribute('direction', 'horizontal')

    newFeatures.append(line)

    # Create vertical line

    line = QgsFeature(lineLayer.fields())
    line.setGeometry(QgsGeometry.fromPolylineXY([QgsPointXY(xmin, ymin), QgsPointXY(xmin, ymax)]))
    line.setAttribute('value', xmin)
    line.setAttribute('min_value', ymin / vertical_exaggeration)
    line.setAttribute('max_value', ymax / vertical_exaggeration)
    line.setAttribute('direction', 'vertical')

    newFeatures.append(line)
    
    lineLayer.dataProvider().addFeatures(newFeatures)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(90)

    """
    Return line layer
    """

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(100)

    debug_print("Grid successfully created!")

    return lineLayer

def createProfileGrid(profile, axis_layer, vertical_exaggeration = 1, interval = 0.01, extremities=False, progress_bar = None, crs=32630):
    """
    ***************************************************************************
    Creates grids for profiles for each axis.

    PARAMETERS:
    * profile : profile line layer or projected points layer to create grid from | instance of QgsVectorLayer class
    * axis_layer : line layer containing axis | instance of QgsVectorLayer class, must be a Line vector layer
    * vertical_exaggeration : vertical exaggeration factor | float
    * interval : number with which to round min and max values | float
    * extremities : indicates whether to create extremities for the axis | boolean
    * progress_bar : progress bar to update | instance of QProgressBar
    * crs : CRS number to use (equidistant) | int
    
    OUTPUTS:
    line layer containing grid | instance of QgsVectorLayer

    *************************************************************************** 
    """

    debug_print("Starting function createProfileGrid.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check progress bar parameter
    
    if progress_bar != None and progress_bar.__class__.__name__ != 'QProgressBar':
        debug_print("Invalid progress bar parameter : not a progress bar")
        return

    # Initiate progress bar

    if progress_bar != None:
        progress_bar_max = progress_bar.maximum()
        progress_bar.setMaximum(0)

    # Check profile parameter

    if profile.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid profiles parameter : not a vector layer")
        return

    if profile.geometryType() != QgsWkbTypes.LineGeometry and profile.geometryType() != QgsWkbTypes.PointGeometry:
        debug_print("Invalid profiles parameter : wrong type of geometry")
        return

    if profile.featureCount() < 1:
        debug_print("Invalid profiles parameter : empty layer")
        return

    # Check axis layer parameter

    if axis_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid axis layer parameter : not a vector layer")
        return

    if axis_layer.geometryType() != QgsWkbTypes.LineGeometry:
        debug_print("Invalid axis layer parameter : wrong type of geometry")
        return

    if axis_layer.featureCount() < 1:
        debug_print("Invalid axis layer parameter : empty layer")
        return

    # Check vertical exaggeration parameter

    if type(vertical_exaggeration) not in [int, long, float]:
        debug_print("Invalid vertical exaggeration parameter : not a number")
        return

    # Check interval parameter

    if type(interval) not in [int, long, float]:
        debug_print("Invalid interval parameter : not a number")
        return

    # Check extremities parameter

    if type(extremities) is not bool:
        debug_print("Invalid extremities parameter : not a boolean")
        return

    # Check CRS parameter

    if type(crs) is not int:
        try:
            crs = int(crs)
        except:
            debug_print("Invalid CRS parameter : not an int")
            return

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(10)

    """
    Get extent of profile for each axis
    """

    debug_print("Getting extent of profile for each axis...")

    extents = {}

    for axis in axis_layer.getFeatures():

        extents[axis['axis_id']] = [math.inf, -math.inf, math.inf, -math.inf]

    for feat in profile.getFeatures():

        axis_id = feat['axis_id']
        axis_geom = None
        for axis in axis_layer.getFeatures():
            if axis['axis_id'] == axis_id:
                axis_geom = axis.geometry()

        value = extents[axis_id]
        if axis_geom != None:
            axis_length = axis_geom.length()
        else:
            axis_length = value[1]

        xmin = 0 #value[0]
        xmax = axis_length #value[1]
        ymin = value[2]
        ymax = value[3]

        if profile.geometryType() == QgsWkbTypes.PointGeometry:
            feat_geom = feat.geometry().asQPointF()
            # if feat_geom.x() < xmin:
            #     xmin = feat_geom.x()
            # if feat_geom.x() > xmax:
            #     xmax = feat_geom.x()
            if feat_geom.y() < ymin:
                ymin = feat_geom.y()
            if feat_geom.y() > ymax:
                ymax = feat_geom.y()
        else:
            feat_geom = feat.geometry().asQPolygonF()
            for point in feat_geom:
                # if point.x() < xmin:
                #     xmin = point.x()
                # if point.x() > xmax:
                #     xmax = point.x()
                if point.y() < ymin:
                    ymin = point.y()
                if point.y() > ymax:
                    ymax = point.y()

        extents[axis_id] = [xmin, xmax, ymin, ymax]

    # Round min and max values according to range

    count_zeros = 0

    ## Find the number of leading zeros in the interval

    str_interval = str(interval)
    for char in str_interval:
        if char != '0' and char != '.':
            break
        elif char == '0':
            count_zeros += 1

    # Calculate the grid interval in exaggerated coordinate space
    # Grid lines are spaced by interval * vertical_exaggeration
    exaggerated_interval = interval * vertical_exaggeration

    for axis_id in extents.keys():
        
        value = extents[axis_id]

        xmin = value[0]
        xmax = value[1]
        ymin = value[2]
        ymax = value[3]

        ## Round min and max values accordingly
        ## Since ymin and ymax are in exaggerated coordinate space, we need to round
        ## them to align with the grid spacing (interval * vertical_exaggeration)

        if count_zeros > 0:
            # rnd = round(xmin, count_zeros)
            # if rnd > xmin:
            #     xmin = round(rnd - 1/(10*count_zeros), count_zeros)
            # else:
            #     xmin = rnd

            # rnd = round(xmax, count_zeros)
            # if rnd < xmax:
            #     xmax = round(rnd + 1/(10*count_zeros), count_zeros)
            # else:
            #     xmax = rnd

            # Round ymin down to the nearest multiple of exaggerated_interval
            # This ensures grid lines align with the projected points
            ymin_rounded = math.floor(ymin / exaggerated_interval) * exaggerated_interval
            # Apply additional rounding for display precision
            ymin = round(ymin_rounded, count_zeros)

            # Round ymax up to the nearest multiple of exaggerated_interval
            ymax_rounded = math.ceil(ymax / exaggerated_interval) * exaggerated_interval
            # Apply additional rounding for display precision
            ymax = round(ymax_rounded, count_zeros)

        extents[axis_id] = [xmin, xmax, ymin, ymax]

    print('extensions')
    print(extents)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(50)

    """
    Create grid line layer
    """

    debug_print("Creating line layer...")

    # Create new line layer
    # Use the crs parameter (defaults to 32630)
    crs_to_use = 'EPSG:' + str(crs)
    debug_print("Creating profile_grid with CRS: " + crs_to_use)
    lineLayer = QgsVectorLayer('LineString?crs=' + crs_to_use, 'profile_grid', 'memory')

    # Add fields

    lineLayer.dataProvider().addAttributes([QgsField('value', QVariant.Double, len = 10, prec = 10), QgsField('base_value', QVariant.Double, len = 10, prec = 10), QgsField('base', QVariant.Int, len = 1, prec = 1), QgsField('min_value', QVariant.Double, len = 10, prec = 10), QgsField('max_value', QVariant.Double, len = 10, prec = 10), QgsField('axis_id', QVariant.Int, len = 10), QgsField('direction', QVariant.String, len = 100)])

    lineLayer.updateFields()

    if extremities:

        # Create new point layer

        extremitiesLayer = QgsVectorLayer('Point?crs=EPSG:' + str(crs), 'grid_extremities', 'memory')

        # Add fields

        extremitiesLayer.dataProvider().addAttributes([QgsField('axis_id', QVariant.Int, len = 10)])
        extremitiesLayer.updateFields()

    newFeatures = []
    newExtr = []

    for axis_id in extents.keys():

        value = extents[axis_id]

        xmin = value[0]
        xmax = value[1]
        ymin = value[2]
        ymax = value[3]

        # Create horizontal lines

        Y = ymin
        while Y <= ymax:
            print('hauteur : ' + str(Y))

            line = QgsFeature(lineLayer.fields())
            line.setGeometry(QgsGeometry.fromPolylineXY([QgsPointXY(xmin, Y), QgsPointXY(xmax, Y)]))
            if Y == ymin:
                line.setAttribute('base', 1)
            else:
                line.setAttribute('base', 0)
            line.setAttribute('base_value', round(ymin / vertical_exaggeration, count_zeros))
            line.setAttribute('value', round(Y / vertical_exaggeration, count_zeros))
            line.setAttribute('min_value', xmin)
            line.setAttribute('max_value', xmax)
            line.setAttribute('axis_id', int(axis_id))
            line.setAttribute('direction', 'horizontal')

            newFeatures.append(line)

            Y += interval * vertical_exaggeration

        # Create vertical line

        line = QgsFeature(lineLayer.fields())
        line.setGeometry(QgsGeometry.fromPolylineXY([QgsPointXY(xmin, ymin), QgsPointXY(xmin, ymax)]))
        line.setAttribute('base', 0)
        line.setAttribute('value', xmin)
        line.setAttribute('min_value', round(ymin / vertical_exaggeration, count_zeros))
        line.setAttribute('max_value', round(ymax / vertical_exaggeration, count_zeros))
        line.setAttribute('axis_id', int(axis_id))
        line.setAttribute('direction', 'vertical')

        newFeatures.append(line)

        if extremities:

            ## Create extremity points

            startPoint = QgsFeature(extremitiesLayer.fields())
            startPoint.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(xmin, ymin)))
            startPoint.setAttribute('axis_id', line['axis_id'])

            newExtr.append(startPoint)

            endPoint = QgsFeature(extremitiesLayer.fields())
            endPoint.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(xmax, ymin)))
            endPoint.setAttribute('axis_id', line['axis_id'])

            newExtr.append(endPoint)
        
    lineLayer.dataProvider().addFeatures(newFeatures)

    if extremities:
        extremitiesLayer.dataProvider().addFeatures(newExtr)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(90)

    """
    Return results
    """

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(100)

    debug_print("Grid successfully created!")

    if extremities:
        return [lineLayer, extremitiesLayer]
    else:
        return lineLayer

def projectObjects(objects_layer, altitude_field, axis_layer, distance, vertical_exaggeration = 1, extremities=False, progress_bar = None, progress_factor = 1, crs=32630, projected_points_layer=None):
    """
    ***************************************************************************
    Creates and returns a point layer containing objects projected along the listed axis.

    PARAMETERS:
    * objects_layer : layer with objects to be projected | instance of QgsVectorLayer, either a Polygon or a Point vector layer
    * altitude_field : name of the field containing altitudes of features in the objects layer | string
    * axis_layer : line layer containing axis | instance of QgsVectorLayer class, must be a Line vector layer
    * distance : maximal distance between object and axis for it to be projected onto the latter | float
    * vertical_exaggeration : vertical exaggeration factor | float
    * extremities : indicates whether to create extremities for the axis | boolean
    * progress_bar : progress bar to update | instance of QProgressBar
    * crs : CRS number to use (equidistant) | int
    * projected_points_layer : pre-created memory layer for projected points (required in QGIS 3.44) | instance of QgsVectorLayer

    OUTPUTS:
    source objects layer filtered by axis + point vector layer with projected objects | list of 2 instances of class QgsVectorLayer

    *************************************************************************** 
    """

    # Check progress bar parameter
    if progress_bar != None and progress_bar.__class__.__name__ != 'QProgressBar':
        debug_print("Invalid progress bar parameter : not a progress bar")
        return [None, None] if not extremities else [None, None, None]

    # Initiate progress bar
    try:
        if progress_bar != None:
            progress_bar_max = progress_bar.maximum()
            progress_bar.setMaximum(0)
    except Exception as e:
        debug_print("Error accessing progress bar: " + str(e))
        return [None, None] if not extremities else [None, None, None]
    
    # Check objects layer parameter
    if objects_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid objects layer parameter : not a vector layer")
        return [None, None] if not extremities else [None, None, None]
    
    if not objects_layer.isValid():
        debug_print("Invalid objects layer parameter : layer is invalid")
        return [None, None] if not extremities else [None, None, None]
    
    geom_type = objects_layer.geometryType()
    if geom_type != QgsWkbTypes.PointGeometry and geom_type != QgsWkbTypes.PolygonGeometry:
        debug_print("Invalid objects layer parameter : wrong type of geometry")
        return [None, None] if not extremities else [None, None, None]

    if objects_layer.featureCount() < 1:
        debug_print("Invalid objects layer parameter : empty layer")
        return [None, None] if not extremities else [None, None, None]
        
    # Check axis layer parameter
    if axis_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid axis layer parameter : not a vector layer")
        return [None, None] if not extremities else [None, None, None]

    if not axis_layer.isValid():
        debug_print("Invalid axis layer parameter : layer is invalid")
        return [None, None] if not extremities else [None, None, None]

    if axis_layer.geometryType() != QgsWkbTypes.LineGeometry:
        debug_print("Invalid axis layer parameter : wrong type of geometry")
        return [None, None] if not extremities else [None, None, None]

    if axis_layer.featureCount() < 1:
        debug_print("Invalid axis layer parameter : empty layer")
        return [None, None] if not extremities else [None, None, None]
    
    # Check altitude field parameter
    if type(altitude_field) is not str:
        debug_print("Invalid altitude field parameter : not a chain of characters")
        return [None, None] if not extremities else [None, None, None]

    altField = None
    try:
        for field in objects_layer.fields():
            if field.name() == altitude_field and field.typeName().lower() in ['float', 'double', 'real']:
                altField = altitude_field
    except Exception as e:
        debug_print("Error accessing objects layer fields: " + str(e))
        return [None, None] if not extremities else [None, None, None]

    if altField == None :
        debug_print("Invalid altitude field parameter : field does not exist or is not a number field")
        return [None, None] if not extremities else [None, None, None]
        
    # Check distance parameter
    if type(distance) not in [int, long, float]:
        debug_print("Invalid distance parameter : not a number")
        return [None, None] if not extremities else [None, None, None]

    if distance <= 0:
        debug_print("Invalid distance parameter : negative number")
        return [None, None] if not extremities else [None, None, None]

    # Check vertical exaggeration parameter
    if type(vertical_exaggeration) not in [int, long, float]:
        debug_print("Invalid vertical exaggeration parameter : not a number")
        return [None, None] if not extremities else [None, None, None]

    # Check extremities parameter
    if type(extremities) is not bool:
        debug_print("Invalid extremities parameter : not a boolean")
        return [None, None] if not extremities else [None, None, None]

    # Check progress factor parameter
    if type(progress_factor) not in [int, long, float]:
        debug_print("Invalid progress factor parameter : not a number")
        return [None, None] if not extremities else [None, None, None]

    # Check CRS parameter
    if type(crs) is not int:
        try:
            crs = int(crs)
        except:
            debug_print("Invalid CRS parameter : not an int")
            return [None, None] if not extremities else [None, None, None]
    
    # Update progress bar
    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(10*progress_factor)

    # Use axis layer directly (skip duplication for QGIS 3.44 compatibility)
    # For QGIS 3.44: Use the original axis_layer directly without any modification
    # CRITICAL: Do NOT call getFeatures() or modify the layer here - it causes immediate crashes
    axisLayer = axis_layer
    
    # Check if axis_id field exists (read-only check, no iteration)
    has_axis_id = False
    try:
        for field in axisLayer.fields():
            if field.name() == 'axis_id':
                has_axis_id = True
                break
    except:
        # If we can't check, assume it exists
        has_axis_id = True
    
    if not has_axis_id:
        debug_print("Warning: axis_id field not found in axis layer - projection may fail")
        # Do NOT try to add the field or modify the layer - this causes crashes in QGIS 3.44

    # Update progress bar
    if progress_bar != None:
        progress_bar.setValue(20*progress_factor)
    
    # Skip extremities generation for now - it uses getFeatures() which crashes
    extremitiesLayer = None
    
    # Create centroids if objects layer is a polygon layer
    if objects_layer.geometryType() != QgsWkbTypes.PointGeometry:
        debug_print("Creating centroids...")

        parameters = {
            'INPUT': objects_layer,
            'ALL_PARTS': False,
            'OUTPUT': 'memory:centroids'
        }

        pointsLayer = runProcessingAlg('native:centroids', parameters)

        if type(pointsLayer) is str:
            pointsLayer = QgsVectorLayer(pointsLayer, 'centroids', 'memory')

        if progress_bar != None:
            progress_bar.setValue(35*progress_factor)
    else:
        pointsLayer = objects_layer

    # Update progress bar
    if progress_bar != None:
        progress_bar.setValue(40*progress_factor)
    
    # Create buffers around axis
    debug_print("Creating buffers around axis...")

    parameters = {
        'INPUT': axisLayer,
        'DISTANCE': distance,
        'SEGMENTS': 5,
        'END_CAP_STYLE': 0,
        'JOIN_STYLE': 0,
        'MITER_LIMIT': 2,
        'DISSOLVE': False,
        'OUTPUT': 'memory:buffers'
    }

    buffersLayer = runProcessingAlg('native:buffer', parameters)

    if type(buffersLayer) is str:
        buffersLayer = QgsVectorLayer(buffersLayer, 'buffers', 'memory')

    if progress_bar != None:
        progress_bar.setValue(50*progress_factor)

    # Join points with buffers
    debug_print("Joining points with buffers...")

    parameters = {
        'DISCARD_NONMATCHING': True,
        'INPUT': pointsLayer,
        'JOIN': buffersLayer,
        'JOIN_FIELDS' : ['axis_id'],
        'METHOD': 0,
        'PREDICATE' : [0,1,4,5,6],
        'OUTPUT' : 'memory:filtered_points'
    }

    filteredPointsLayer = runProcessingAlg('native:joinattributesbylocation', parameters)
    
    # Validate that we got a valid layer (QGIS 3.44 compatibility)
    if filteredPointsLayer is None:
        debug_print("Error: Failed to create filtered points layer")
        if progress_bar != None:
            progress_bar.setMaximum(progress_bar_max)
            progress_bar.setValue(100*progress_factor)
        return [None, None] if not extremities else [None, None, None]
    
    if not filteredPointsLayer.isValid():
        debug_print("Error: Filtered points layer is invalid")
        if progress_bar != None:
            progress_bar.setMaximum(progress_bar_max)
            progress_bar.setValue(100*progress_factor)
        return [filteredPointsLayer, None] if not extremities else [filteredPointsLayer, None, None]
    
    objectsToProjectLayer = filteredPointsLayer

    if objects_layer.geometryType() == QgsWkbTypes.PolygonGeometry:
        try:
            # Join polygons with centroid
            parameters = {
                'FIELD': 'fid',
                'FIELDS TO COPY': ['axis_id'],
                'FIELD_2': 'fid',
                'INPUT': objects_layer,
                'INPUT_2': filteredPointsLayer,
                'OUTPUT' : 'memory:populated_polys'
            }

            popPolysLayer = runProcessingAlg('native:joinattributestable', parameters)

            # Delete polys with no axis ID
            parameters = {
                'FIELD': 'axis_id',
                'INPUT': popPolysLayer,
                'OPERATOR': 9,
                'VALUE': '',
                'OUTPUT' : 'memory:filtered_polys'
            }

            filteredPolysLayer = runProcessingAlg('native:extractbyattribute', parameters)
            objectsToProjectLayer = filteredPolysLayer
        except Exception as e:
            debug_print("Error in polygon filtering: " + str(e))
            # Continue with filteredPointsLayer

    if progress_bar != None:
        progress_bar.setValue(60*progress_factor)
    
    # Use the pre-created projection layer passed as parameter (workaround for QGIS 3.44)
    # Creating QgsVectorLayer inside this function causes crashes
    if projected_points_layer is None:
        debug_print("Error: No projection layer provided")
        return [None, None] if not extremities else [None, None, None]
    
    if not projected_points_layer.isValid():
        debug_print("Error: Provided projection layer is invalid")
        return [None, None] if not extremities else [None, None, None]
    
    projectedPointsLayer = projected_points_layer
    
    # Add fields from objects_layer to projectedPointsLayer
    # We can't access filteredPointsLayer.fields() - it crashes in QGIS 3.44
    
    # Get fields from objects_layer (original source) instead of filteredPointsLayer
    # This should be safe since objects_layer is the original input layer
    try:
        fields_to_add = []
        for field in objects_layer.fields():
            fields_to_add.append(QgsField(field.name(), field.type(), field.typeName(), field.length(), field.precision(), field.comment()))
        
        # Also add axis_id field if not already present
        has_axis_id = False
        for field in projectedPointsLayer.fields():
            if field.name() == 'axis_id':
                has_axis_id = True
                break
        
        if not has_axis_id:
            fields_to_add.append(QgsField('axis_id', QVariant.Int, len=10))
        else:
            # Add other fields but skip axis_id since it exists
            existing_fields = [f.name() for f in projectedPointsLayer.fields()]
            fields_to_add = [f for f in fields_to_add if f.name() not in existing_fields]
        
        if fields_to_add:
            projectedPointsLayer.dataProvider().addAttributes(fields_to_add)
            projectedPointsLayer.updateFields()
    except Exception as e:
        debug_print("Warning: Could not add all fields: " + str(e))
        # Continue anyway - we'll add features with available fields
    
    # Add projected points
    newFeatures = []
    
    try:
        # Iterate through filtered points
        for point_feature in filteredPointsLayer.getFeatures():
            try:
                # Get point geometry
                point_geom = point_feature.geometry()
                if point_geom is None:
                    continue
                
                # Check if geometry is empty (avoid isValid() which doesn't exist in QGIS 3.44)
                try:
                    if point_geom.isEmpty():
                        continue
                except:
                    pass  # isEmpty() might not be available, continue
                
                # Create independent copy using WKT (avoid isValid() calls)
                try:
                    wkt = point_geom.asWkt()
                    if not wkt or len(wkt) == 0:
                        continue
                    point_geom_copy = QgsGeometry.fromWkt(wkt)
                    if point_geom_copy is None:
                        continue
                    # Check if copy is empty
                    try:
                        if point_geom_copy.isEmpty():
                            continue
                    except:
                        pass
                except Exception as e:
                    continue
                
                # Get axis_id
                try:
                    axis_id = point_feature['axis_id']
                    if axis_id is None:
                        continue
                except:
                    continue
                
                # Get axis geometry using getFeature() by ID (safe for QGIS 3.44)
                axis_geom = None
                try:
                    axis_feat = axisLayer.getFeature(int(axis_id))
                    try:
                        is_valid = axis_feat.isValid()
                    except:
                        is_valid = axis_feat and hasattr(axis_feat, 'geometry')
                    
                    if is_valid:
                        try:
                            source_geom = axis_feat.geometry()
                            if source_geom is None:
                                raise ValueError("Geometry is None")
                            
                            # Check if empty (avoid isValid() call)
                            try:
                                if source_geom.isEmpty():
                                    raise ValueError("Geometry is empty")
                            except:
                                pass
                            
                            # Check geometry type
                            try:
                                geom_type = source_geom.type()
                                if geom_type != QgsWkbTypes.LineGeometry:
                                    raise ValueError("Not a line geometry")
                            except:
                                pass
                            
                            # Create copy using WKT
                            try:
                                wkt = source_geom.asWkt()
                                axis_geom = QgsGeometry.fromWkt(wkt)
                                if axis_geom is None:
                                    raise ValueError("Failed to create geometry copy")
                            except:
                                axis_geom = None
                                
                        except:
                            axis_geom = None
                except:
                    continue
                
                if axis_geom is None:
                    continue
                
                # Calculate projected coordinates
                projX = None
                try:
                    projX = axis_geom.lineLocatePoint(point_geom_copy)
                    if projX is None or (isinstance(projX, float) and (math.isnan(projX) or math.isinf(projX))):
                        continue
                    if projX < 0:
                        projX = 0.0
                except:
                    continue
                
                # Get altitude value
                try:
                    altValue = point_feature[altField]
                except:
                    continue
                
                # Check if altitude is a numeric type (float, int, long)
                if type(altValue) not in [int, long, float]:
                    continue
                
                # Convert to float if needed
                try:
                    altValue = float(altValue)
                except:
                    continue
                
                projY = altValue * vertical_exaggeration
                
                # Create projected point feature
                projectedPoint = QgsFeature(projectedPointsLayer.fields())
                projectedPoint.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(projX, projY)))
                projectedPoint.setAttribute('axis_id', axis_id)
                
                # Copy attributes from original point
                for field in projectedPointsLayer.fields():
                    try:
                        field_name = field.name()
                        if field_name != 'axis_id':
                            try:
                                value = point_feature[field_name]
                                projectedPoint.setAttribute(field_name, value)
                            except:
                                pass
                    except:
                        pass
                
                newFeatures.append(projectedPoint)
                
            except Exception as e:
                continue
        
        # Add features to layer
        if newFeatures:
            projectedPointsLayer.dataProvider().addFeatures(newFeatures)
        
    except Exception as e:
        debug_print("Error in projection loop: " + str(e))
    
    # Update progress bar
    if progress_bar != None:
        progress_bar.setValue(90*progress_factor)
    
    return [objectsToProjectLayer, projectedPointsLayer] if not extremities else [objectsToProjectLayer, extremitiesLayer, projectedPointsLayer]

def createLinks(links_layer, objects_layer, links_layer_fields, objects_layer_field, progress_bar = None):
    """
    ***************************************************************************
    Creates and returns a line layer containing links between objects according to the links data layer.

    PARAMETERS:
    * links_layer : layer with links to be created | instance of QgisVectorLayer
    * objects_layer : layer with objects to be linkes | instance of QgsVectorLayer, either a Polygon or a Point vector layer
    * links_layer_field : list of names of the fields containing the objects ids in the links layer | list of 2 strings
    * objects_layer_field : name of the id field in the objects layer | string
    * progress_bar : progress bar to update | instance of QProgressBar

    OUTPUTS:
    line vector layer with links between objects | instance of class QgsVectorLayer

    *************************************************************************** 
    """

    debug_print("Starting function createLinks.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check progress bar parameter
    
    if progress_bar != None and progress_bar.__class__.__name__ != 'QProgressBar':
        debug_print("Invalid progress bar parameter : not a progress bar")
        return

    # Initiate progress bar

    if progress_bar != None:
        progress_bar_max = progress_bar.maximum()
        progress_bar.setMaximum(0)

    # Check links layer parameter

    if links_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid links layer parameter : not a vector layer")
        return

    if links_layer.featureCount() < 1:
        debug_print("Invalid links layer parameter : empty layer")
        return

    # Check objects layer parameter

    if objects_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid objects layer parameter : not a vector layer")
        return
    
    if objects_layer.geometryType() != QgsWkbTypes.PointGeometry and objects_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
        debug_print("Invalid objects layer parameter : wrong type of geometry")
        return

    if objects_layer.featureCount() < 1:
        debug_print("Invalid objects layer parameter : empty layer")
        return

    # Check links layer fields parameter

    if type(links_layer_fields) is not list:
        debug_print("Invalid links layer fields parameter : not a list")
        return

    if len(links_layer_fields) != 2:
        debug_print("Invalid links layer fields parameter : wrong number of items in list")
        return

    idField1 = None
    idField2 = None

    for field in links_layer.fields():
        if field.name() == links_layer_fields[0]:
            idField1 = links_layer_fields[0]
        elif field.name() == links_layer_fields[1]:
            idField2 = links_layer_fields[1]

    if idField1 == None or idField2 == None or idField1 == idField2:
        debug_print("Invalid links layer fields parameter : at least one of the fields does not exist")
        return

    # Check objects layer field parameter

    if type(objects_layer_field) is not str:
        debug_print("Invalid objects layer field parameter : not a chain of characters")
        return

    idField = None

    for field in objects_layer.fields():
        if field.name() == objects_layer_field:
            idField = objects_layer_field

    if idField == None:
        debug_print("Invalid objects layer field parameter : field does not exist")
        return

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(10)

    """
    Create centroids if objects layer is a polygon layer
    """

    if objects_layer.geometryType() != QgsWkbTypes.PointGeometry:

        debug_print("Creating centroids...")

        parameters = {
            'INPUT': objects_layer,
            'ALL_PARTS': False,
            'OUTPUT': 'memory:centroids'
        }

        pointsLayer = runProcessingAlg('native:centroids', parameters)

        if progress_bar != None:
            progress_bar.setValue(15)

    else:
        pointsLayer = objects_layer

    #QgsProject.instance().addMapLayer(pointsLayer)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(20)

    """
    Create line for each link
    """

    debug_print("Creating line for each link...")

    # Create new line layer

    lineLayer = QgsVectorLayer('LineString?crs=' + str(QgsProject.instance().crs().authid()), 'links', 'memory')

    # Add attributes

    fields = links_layer.dataProvider().fields().toList()
    lineLayer.dataProvider().addAttributes(fields)
    lineLayer.updateFields()

    # Add features

    newFeatures = []

    for link in links_layer.getFeatures():

        ## Get corresponding points

        point1 = None
        point2 = None

        for point in pointsLayer.getFeatures():
            if point[idField] == link[idField1]:
                point1 = point
            elif point[idField] == link[idField2]:
                point2 = point

        ## Get points coordinates

        if point1 != None and point2 != None:
            X1 = point1.geometry().asQPointF().x()
            Y1 = point1.geometry().asQPointF().y()

            X2 = point2.geometry().asQPointF().x()
            Y2 = point2.geometry().asQPointF().y()

            ## Create projected point

            line = QgsFeature(lineLayer.fields())
            for field in list(links_layer.fields()):
                for aField in list(lineLayer.fields()):
                    if aField.name() == field.name():
                        line.setAttribute(field.name(), link[field.name()])
            line.setGeometry(QgsGeometry.fromPolylineXY([QgsPointXY(X1, Y1), QgsPointXY(X2, Y2)]))

            newFeatures.append(line)

    lineLayer.dataProvider().addFeatures(newFeatures)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(90)

    """
    Return line layer
    """

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(100)

    debug_print("Links successfully created!")

    return lineLayer

def projectLinks(links_layer, objects_layer, links_layer_fields, objects_layer_field, altitude_field, axis_layer, distance, vertical_exaggeration = 1, progress_bar = None, crs=32630):
    """
    ***************************************************************************
    Creates and returns a line layer containing links between objects according to the links data layer, projected along the listed axis.

    PARAMETERS:
    * links_layer : layer with links to be created | instance of QgisVectorLayer
    * objects_layer : layer with objects to be linkes | instance of QgsVectorLayer, either a Polygon or a Point vector layer
    * links_layer_field : list of names of the fields containing the objects ids in the links layer | list of 2 strings
    * objects_layer_field : name of the id field in the objects layer | string
    * altitude_field : name of the field containing altitudes of features in the objects layer | string
    * axis_layer : line layer containing axis | instance of QgsVectorLayer class, must be a Line vector layer
    * distance : maximal distance between object and axis for it to be projected onto the latter | float
    * vertical_exaggeration : vertical exaggeration factor | float
    * progress_bar : progress bar to update | instance of QProgressBar
    * crs : CRS number to use (equidistant) | int

    OUTPUTS:
    line vector layer with projected links between objects | instance of class QgsVectorLayer

    *************************************************************************** 
    """

    debug_print("Starting function projectLinks.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check progress bar parameter
    
    if progress_bar != None and progress_bar.__class__.__name__ != 'QProgressBar':
        debug_print("Invalid progress bar parameter : not a progress bar")
        return

    # Initiate progress bar

    if progress_bar != None:
        progress_bar_max = progress_bar.maximum()
        progress_bar.setMaximum(0)

    # Check links layer parameter

    if links_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid links layer parameter : not a vector layer")
        return

    if links_layer.featureCount() < 1:
        debug_print("Invalid links layer parameter : empty layer")
        return

    # Check objects layer parameter

    if objects_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid objects layer parameter : not a vector layer")
        return
    
    if objects_layer.geometryType() != QgsWkbTypes.PointGeometry and objects_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
        debug_print("Invalid objects layer parameter : wrong type of geometry")
        return

    if objects_layer.featureCount() < 1:
        debug_print("Invalid objects layer parameter : empty layer")
        return

    # Check links layer fields parameter

    if type(links_layer_fields) is not list:
        debug_print("Invalid links layer fields parameter : not a list")
        return

    if len(links_layer_fields) != 2:
        debug_print("Invalid links layer fields parameter : wrong number of items in list")
        return

    idField1 = None
    idField2 = None

    for field in links_layer.fields():
        if field.name() == links_layer_fields[0]:
            idField1 = links_layer_fields[0]
        elif field.name() == links_layer_fields[1]:
            idField2 = links_layer_fields[1]

    if idField1 == None or idField2 == None or idField1 == idField2:
        debug_print("Invalid links layer fields parameter : at least one of the fields does not exist")
        return

    # Check objects layer field parameter

    if type(objects_layer_field) is not str:
        debug_print("Invalid objects layer field parameter : not a chain of characters")
        return

    idField = None

    for field in objects_layer.fields():
        if field.name() == objects_layer_field:
            idField = objects_layer_field

    if idField == None:
        debug_print("Invalid objects layer field parameter : field does not exist")
        return

    # Check altitude field parameter

    if type(altitude_field) is not str:
        debug_print("Invalid altitude field parameter : not a chain of characters")
        return

    altField = None

    for field in objects_layer.fields():
        if field.name() == altitude_field and field.typeName().lower() in ['float', 'double', 'real']:
            altField = altitude_field

    if altField == None :
        debug_print("Invalid altitude field parameter : field does not exist or is not a number field")
        return

    # Check axis layer parameter

    if axis_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid axis layer parameter : not a vector layer")
        return

    if axis_layer.geometryType() != QgsWkbTypes.LineGeometry:
        debug_print("Invalid axis layer parameter : wrong type of geometry")
        return

    if axis_layer.featureCount() < 1:
        debug_print("Invalid axis layer parameter : empty layer")
        return

    # Check distance parameter

    if type(distance) not in [int, long, float]:
        debug_print("Invalid distance parameter : not a number")
        return

    if distance <= 0:
        debug_print("Invalid distance parameter : negative number")
        return

    # Check vertical exaggeration parameter

    if type(vertical_exaggeration) not in [int, long, float]:
        debug_print("Invalid vertical exaggeration parameter : not a number")
        return

    # Check CRS parameter

    if type(crs) is not int:
        try:
            crs = int(crs)
        except:
            debug_print("Invalid CRS parameter : not an int")
            return

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(10)

    """
    Project objects
    """

    debug_print("Projecting objects...")

    projectedPointsLayer = projectObjects(objects_layer, altitude_field, axis_layer, distance, vertical_exaggeration, progress_bar = progress_bar, progress_factor = 0.8)[1]

    #QgsProject.instance().addMapLayer(projectedPointsLayer)

    """
    Project links on their axis
    """

    debug_print("Projecting links on their axis...")

    # Create new line layer

    projectedLinesLayer = QgsVectorLayer('LineString?crs=EPSG:' + str(crs), 'projected_links', 'memory')

    # Add fields

    projectedLinesLayer.dataProvider().addAttributes([QgsField('axis_id', QVariant.Int, len = 10)] + list(links_layer.fields()))
    projectedLinesLayer.updateFields()

    # Add projected lines

    newFeatures = []

    for link in links_layer.getFeatures():

        for axis in axis_layer.getFeatures():

            ## Get corresponding points

            point1 = None
            point2 = None

            #for point in filteredPointsLayer.getFeatures():
            for point in projectedPointsLayer.getFeatures():
                if point[idField] == link[idField1] and point['axis_id'] == axis['axis_id']:
                    point1 = point
                elif point[idField] == link[idField2] and point['axis_id'] == axis['axis_id']:
                    point2 = point

            if point1 != None and point2 != None and point1['axis_id'] == axis['axis_id'] and point2['axis_id'] == axis['axis_id']:

                ## Get projected points coordinates

                X1 = point1.geometry().asQPointF().x()
                Y1 = point1.geometry().asQPointF().y()

                X2 = point2.geometry().asQPointF().x()
                Y2 = point2.geometry().asQPointF().y()

                ## Create projected line

                if Y1 != None and Y2 != None:

                    projectedLine = QgsFeature(projectedLinesLayer.fields())
                    #projectedLine.setGeometry(QgsGeometry.fromPolylineXY([QgsPointXY(projX1, projY1), QgsPointXY(projX2, projY2)]))
                    projectedLine.setGeometry(QgsGeometry.fromPolylineXY([QgsPointXY(X1, Y1), QgsPointXY(X2, Y2)]))
                    projectedLine.setAttribute('axis_id', axis['axis_id'])
                    for field in links_layer.fields():
                        projectedLine.setAttribute(field.name(), link[field.name()])

                    newFeatures.append(projectedLine)

    projectedLinesLayer.dataProvider().addFeatures(newFeatures)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(90)

    """
    Return projected links layer
    """

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(100)

    debug_print("Projected links successfully created!")

    return projectedLinesLayer

def filterByAxis(axis_layer, axis_id, layers, id_field, progress_bar = None):
    """
    ***************************************************************************
    Filters listed layers by the input id.

    PARAMETERS:
    * axis_layer : line layer containing axis | instance of QgsVectorLayer class, must be a Line vector layer
    * axis_id : value of id to be filtered | int
    * layers : list of layers to be filtered | list of instances of QgsVectorLayer class
    * id_field : name of field to use for filtering | string
    * progress_bar : progress bar to update | instance of QProgressBar

    OUTPUTS:
    success indicator | boolean

    *************************************************************************** 
    """

    debug_print("Starting function filterByAxis.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check progress bar parameter
    
    if progress_bar != None and progress_bar.__class__.__name__ != 'QProgressBar':
        debug_print("Invalid progress bar parameter : not a progress bar")
        return

    # Initiate progress bar

    if progress_bar != None:
        progress_bar_max = progress_bar.maximum()
        progress_bar.setMaximum(0)

    # Check axis layer parameter

    if axis_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid axis layer parameter : not a vector layer")
        return

    if axis_layer.geometryType() != QgsWkbTypes.LineGeometry:
        debug_print("Invalid axis layer parameter : wrong type of geometry")
        return

    if axis_layer.featureCount() < 1:
        debug_print("Invalid axis layer parameter : empty layer")
        return

    # Check axis id parameter

    if type(axis_id) is not str and axis_id != '':
        debug_print("Invalid axis id parameter : not a chain of characters or empty chain of characters")
        return

    # Check layers parameter

    if type(layers) is not list:
        debug_print("Invalid layers parameter : not a list")
        return

    if len(layers) < 1:
        debug_print("Invalid layers parameter : empty list")
        return

    for layer in layers:
        if layer.__class__.__name__ != 'QgsVectorLayer':
            debug_print("Invalid layers parameter : not a vector layer")
            return

    # Check id field parameter

    if type(id_field) is not str:
        debug_print("Invalid id field parameter : not a chain of characters")
        return

    i = 0
    while i < len(layers):

        layer = layers[i]

        idField = None

        for field in layer.fields():
            if field.name() == id_field:
                idField = id_field

        if idField == None :
            debug_print("Invalid id field parameter : field does not exist")
            return

        i += 1

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(10)

    """
    Filter layers
    """

    debug_print("Filtering layers...")

    i = 0
    while i < len(layers):

        layer = layers[i]

        if axis_id != '':
            try:
                axis_id = int(axis_id)
                axis_id = str(axis_id)
            except:
                axis_id = '\'' + axis_id + '\''
            filterString = '"' + idField + '" = ' + axis_id
        else:
            filterString = ''

        layer.setSubsetString(filterString)

        i += 1

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(90)

    """
    Return success indicator
    """

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(100)

    debug_print("Layers successfully filtered!")

    return True

def configureAxisAtlas(composer_name, axis_layer, layers, id_field, progress_bar = None):
    """
    ***************************************************************************
    Configures an atlas on the composer of a project for defined axis and modifies layers symbology accordingly.

    PARAMETERS:
    * composer_name : name of existing composer or of composer to be created | string
    * axis_layer : line layer containing axis | instance of QgsVectorLayer class, must be a Line vector layer
    * layers : list of layers where symbology must be edited according to atlas | list of instances of QgsVectorLayer class
    * id_field : field name to indicate axis id | string
    * progress_bar : progress bar to update | instance of QProgressBar

    OUTPUTS:
    success indicator | boolean

    *************************************************************************** 
    """

    debug_print("Starting function configureAxisAtlas.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check progress bar parameter
    
    if progress_bar != None and progress_bar.__class__.__name__ != 'QProgressBar':
        debug_print("Invalid progress bar parameter : not a progress bar")
        return

    # Initiate progress bar

    if progress_bar != None:
        progress_bar_max = progress_bar.maximum()
        progress_bar.setMaximum(0)

    # Check composer name parameter

    if type(composer_name) is not str:
        debug_print("Invalid composer name parameter : not a chain of characters")
        return

    # Check axis layer parameter

    if axis_layer.__class__.__name__ != 'QgsVectorLayer':
        debug_print("Invalid axis layer parameter : not a vector layer")
        return

    if axis_layer.geometryType() != QgsWkbTypes.LineGeometry:
        debug_print("Invalid axis layer parameter : wrong type of geometry")
        return

    if axis_layer.featureCount() < 1:
        debug_print("Invalid axis layer parameter : empty layer")
        return

    # Check layers parameter

    if type(layers) is not list:
        debug_print("Invalid layers parameter : not a list")
        return

    if len(layers) < 1:
        debug_print("Invalid layers parameter : empty list")
        return

    for layer in layers:
        if layer.__class__.__name__ != 'QgsVectorLayer':
            debug_print("Invalid layers parameter : not a list of vector layers")
            return

    # Check id fields parameter

    if type(id_field) is not str:
        debug_print("Invalid id field parameter : not a chain of characters")
        return

    i = 0
    while i < len(layers):

        layer = layers[i]

        idField = None

        for field in layer.fields():
            if field.name() == id_field:
                idField = id_field

        if idField == None :
            debug_print("Invalid id field parameter : field does not exist")
            return

        i += 1

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(10)

    """
    Create project variable atlas
    """

    debug_print('Creating project variable...')

    QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'atlas', '')

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(20)

    """
    Set up composer atlas
    """

    debug_print('Setting up composer atlas...')

    # Get or create composer

    if QgsProject.instance().layoutManager().layoutByName(composer_name):
        layout = QgsProject.instance().layoutManager().layoutByName(composer_name)

    else:
        layout = QgsPrintLayout(QgsProject.instance())
        layout.setName(composer_name)
        QgsProject.instance().layoutManager().addLayout(layout)

    # Set up atlas

    layout.atlas().setCoverageLayer(axis_layer)
    layout.atlas().setEnabled(True)

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(30)

    """
    Create layout variable atlas
    """

    debug_print('Creating layout variable atlas...')

    QgsExpressionContextUtils.setLayoutVariable(layout, 'atlas', axis_layer.name())

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(60)

    """
    Edit symbology of layers
    """

    debug_print('Editing symbology of layers...')

    i = 0
    while i < len(layers):

        layer = layers[i]

        # Convert renderer to rule-based renderer

        renderer = QgsRuleBasedRenderer.convertFromRenderer(layer.renderer())
        atlasRuleExists = False

        # List existing rules

        rulesNb = len(renderer.rootRule().children())
        rulesToMove = []

        if rulesNb > 0:

            j = 0
            while j < rulesNb:

                childRule = renderer.rootRule().children()[j]
                if childRule.label() == ATLAS_RULE_NAME:
                    atlasRuleExists = True
                    break
                rulesToMove.append(childRule)

                j += 1

        if not atlasRuleExists:

            # Calculate rule expression

            expression = 'CASE WHEN @atlas = \'' + axis_layer.name() + '\' THEN "' + id_field + '" = @atlas_featureid ELSE 1 END'

            # Create atlas rule

            atlasRule = renderer.rootRule().children()[0].clone()

            atlasRule.setLabel(ATLAS_RULE_NAME)
            atlasRule.setFilterExpression(expression)
            atlasRule.setSymbol(None)

            # Add all root level rules inside atlas rule

            for childRule in rulesToMove:

                atlasRule.appendChild(childRule.clone())

            #  Delete all root level rules

            j = 0
            while j < len(renderer.rootRule().children()):

                renderer.rootRule().removeChildAt(j)

                j += 1

            # Add atlas rule

            renderer.rootRule().appendChild(atlasRule)
            if len(renderer.rootRule().children()) > 1:
                renderer.rootRule().removeChildAt(0)

            layer.setRenderer(renderer)

        i += 1

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(90)

    """
    Return success indicator
    """

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(100)

    debug_print("Atlas successfully configured!")

    return True

def drawConnectionLines(layout, maps, layers, field, progress_bar = None):
    """
    ***************************************************************************
    Creates connecting lines between instances of the same geometry between maps on layout.

    PARAMETERS:
    * layout : layout on which to draw lines | instance of QgsPrintLayout class
    * maps : list of 2 map ids | list of strings
    * layers : list of 2 lists of 0 or 1 layer to connect | list of instances of QgsVectorLayout class
    * field : name of field for correspondance | string
    * progress_bar : progress bar to update | instance of QProgressBar class
    
    OUTPUTS:
    created lines ids | list of strings

    *************************************************************************** 
    """

    debug_print("Starting function drawConnectionLines.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check progress bar parameter
    
    if progress_bar != None and progress_bar.__class__.__name__ != 'QProgressBar':
        debug_print("Invalid progress bar parameter : not a progress bar")
        return

    # Initiate progress bar

    if progress_bar != None:
        progress_bar_max = progress_bar.maximum()
        progress_bar.setMaximum(0)

    # Check layout parameter

    if layout.__class__.__name__ not in ['QgsPrintLayout', 'QgsMasterLayoutInterface']:
        debug_print("Invalid layout parameter : not a layout")
        return

    if layout.atlas().coverageLayer() == None:
        debug_print("Invalid layout parameter : layout does not have an atlas")
        return

    # Check maps parameter

    if type(maps) is not list:
        debug_print("Invalid maps parameter : not a list")
        return

    if len(maps) != 2:
        debug_print("Invalid maps parameter : wrong number of items in list")
        return

    for map_id in maps:
        if type(map_id) is not str and map_id.__class__.__name__ != 'QgsLayoutItemMap' and map_id.__class__.__name__ != 'QgsLayoutItem':
            debug_print("Invalid maps parameter : not a layout item")
            return

        if type(map_id) is str and sip.cast(layout.itemById(map_id), QgsLayoutItemMap):
            _map = sip.cast(layout.itemById(map_id), QgsLayoutItemMap)
        elif type(map_id) is str:
            debug_print("Invalid maps parameter : map id does not exist")
            return

    # Check layers parameter

    if type(layers) is not list:
        debug_print("Invalid layers parameter : not a list")
        return

    if len(layers) != 2:
        debug_print("Invalid layers parameter : wrong number of items in list")
        return

    for map_layers in layers:
        if len(map_layers) > 1:
            debug_print("Invalid layers parameter : wrong number of layers in the list items")
            return

        for layer in map_layers:
            if layer.__class__.__name__ != 'QgsVectorLayer':
                debug_print("Invalid layers parameter : layers in the list items are not vector layers")
                return

            if layer.geometryType() != QgsWkbTypes.LineGeometry and layer.geometryType() != QgsWkbTypes.PointGeometry:
                debug_print("Invalid layers parameter : layers in the list items have the wrong type of geometry")
                return

    # Check field parameter

    if type(field) is not str:
        debug_print("Invalid field parameter : not a chain of characters")
        return

    field_constant = True
    for layer in layers:
        hasField = False
        for aField in layer.fields():
            if aField.name() == field:  
                hasField = True
                break
        if not hasField:    
            field_constant = False
            break
    if not field_constant:
        debug_print("Invalid field parameter : field does not exist in all layers")
        return

    # Update progress bar

    if progress_bar != None:
        progress_bar.setMaximum(progress_bar_max)
        progress_bar.setValue(10)

    """
    Calculate line coordinates
    """

    debug_print("Calculating line coordinates...")

    lines_coords = []
    group_coords = []

    for map_layers in layers:

        if len(map_layers) == 1:
            layer = map_layers[0]
            feat_txt = "get_feature(" + layer.name() + ", " + field + ", @atlas_featureid)[0])"
        else:
            layer = layout.atlas().coverageLayer()
            feat_txt = "@atlas_feature"

        geom_coords = []

        if layer.geometryType() == QgsWkbTypes.PointGeometry:

            X = "layout_X( " + layout.name() + ", geometry(" + feat_txt + "), '" + map_id + "')"
            Y = "layout_Y( " + layout.name() + ", geometry(" + feat_txt + "), '" + map_id + "')"
            geom_coords.append([X, Y])

        elif layer.geometryType() == QgsWkbTypes.LineGeometry:

            startX = "layout_X( " + layout.name() + ", start_point(geometry(" + feat_txt + ")), '" + map_id + "')"
            startY = "layout_Y( " + layout.name() + ", start_point(geometry(" + feat_txt + ")), '" + map_id + "')"
            geom_coords.append([startX, startY])

            endX = "layout_X( " + layout.name() + ", end_point(geometry(" + feat_txt + ")), '" + map_id + "')"
            endY = "layout_Y( " + layout.name() + ", end_point(geometry(" + feat_txt + ")), '" + map_id + "')"
            geom_coords.append([endX, endY])

        group_coords.append(geom_coords)

    i = 0

    while i < len(maps)-1:

        geom_coords1 = group_coords[i]
        geom_coords2 = group_coords[i+1]

        ## Calculate first line coordinates

        line1_coords = [geom_coords1[0], geom_coords2[0]]
        lines_coords.append(line1_coords)

        if len(geom_coords1) == 2 or len(geom_coords2) == 2:

            ## Calculate second line coordinates

            line2_coords = [geom_coords1[-1], geom_coords2[-1]]
            lines_coords.append(line2_coords)

        i += 1

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(50)

    """
    Draw lines
    """

    debug_print("Drawing lines...")

    count = 0
    created_ids = []

    for line_coords in lines_coords:

        line = QgsLayoutItemPolyline(layout)
        line.setId('connecting_line_' + str(count))

        line.addNode(QPointF(0,0))
        line.addNode(QPointF(1,1))

        line.setDataDefinedProperty('PositionX', line_coords[0][0])
        line.setDataDefinedProperty('PositionY', line_coords[0][1])

        line.setDataDefinedProperty('ItemWidth', line_coords[1][0] + "-" + line_coords[0][0])
        line.setDataDefinedProperty('ItemHeight', line_coords[1][1] + "-" + line_coords[0][1])

        line.setLocked(True)

        layout.addLayoutItem(line)
        created_ids.append(line.id())

        count += 1

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(90)

    """
    Return list of created lines ids
    """

    # Update progress bar

    if progress_bar != None:
        progress_bar.setValue(100)

    debug_print("Connection lines successfully created!")

    return created_ids

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

######################
### QGIS FUNCTIONS ###
######################

@qgsfunction(args='auto', group='Custom')
def layout_X(layoutName, geom, map_id, feature, parent):
    """
    Renvoie la coordonnée X du point dans la mise en page.
    <h2>Arguments:</h2>
    <ul>
      <li><b>layoutName</b> : nom de la mise en page - remplacer par @layout_name dans l'expression</li>
      <li><b>geom<\b> : géométrie de point</li>
      <li><b>map_id<\b> : identifiant de la carte ou '' pour la carte de référence</li>
    </ul>
    """

    layout = QgsProject.instance().layoutManager().layoutByName(str(layoutName))

    if map_id == '':
        ref_map = layout.referenceMap()
    else:
        ref_map = sip.cast(layout.itemById(str(map_id)), QgsLayoutItemMap)

    map_position = ref_map.pagePositionWithUnits()

    if geom.type() == 0:
        point = geom.asQPointF()
        lpoint_x = ref_map.mapToItemCoords(point).x() + map_position.x()
        return lpoint_x

    else:
        return NULL

@qgsfunction(args='auto', group='Custom')
def layout_Y(layoutName, geom, map_id, feature, parent):
    """
    Renvoie la coordonnée Y du point dans la mise en page.
    <h2>Arguments:</h2>
    <ul>
      <li><b>layoutName</b> : nom de la mise en page - remplacer par @layout_name dans l'expression</li>
      <li><b>geom<\b> : géométrie de point</li>
      <li><b>map_id<\b> : identifiant de la carte ou '' pour la carte de référence</li>
    </ul>
    """

    layout = QgsProject.instance().layoutManager().layoutByName(str(layoutName))

    if map_id == '':
        ref_map = layout.referenceMap()
    else:
        ref_map = sip.cast(layout.itemById(str(map_id)), QgsLayoutItemMap)

    map_position = ref_map.pagePositionWithUnits()

    if geom.type() == 0:
        point = geom.asQPointF()
        lpoint_y = ref_map.mapToItemCoords(point).y() + map_position.y()
        return lpoint_y

    else:
        return NULL

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

########################
### HELPER FUNCTIONS ###
########################

def populateComboBox(combobox, valueList):
    """
    ***************************************************************************
    Adds items from list to specified combobox.

    PARAMETERS:
    * combobox : combo box | instance of QComboBox class
    * valueList : list of values | list of strings
    
    OUTPUTS:
    success indicator | boolean

    *************************************************************************** 
    """

    debug_print("Starting function populateComboBox.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check combo box parameter

    if combobox.__class__.__name__ != 'QComboBox':
        debug_print("Invalid combo box parameter : not a combo box")
        return

    # Check value list parameter

    if type(valueList) is not list:
        debug_print("Invalid value list parameter : not a list")
        debug_print(valueList)
        return

    if len(valueList) < 1:
        debug_print("Invalid value list parameter : empty list")
        return

    for value in valueList:
        if type(value) is not str:
            debug_print("Invalid value list parameter : not a list of chains of characters")
            return

    """
    Adding items
    """

    debug_print("Adding items...")

    combobox.addItems(valueList)

    """
    Return success indicator
    """

    debug_print("Combo box successfully populated!")

    return True

def setComboBoxIndex(combobox, value=None):
    """
    ***************************************************************************
    Sets the combo box index according to given value.

    PARAMETERS:
    * combobox : combo box | instance of QComboBox class
    * value : value to pick | object
    
    OUTPUTS:
    success indicator | boolean

    *************************************************************************** 
    """

    debug_print("Starting function setComboBoxIndex.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check combo box parameter

    if combobox.__class__.__name__ != 'QComboBox':
        debug_print("Invalid combo box parameter : not a combo box")
        return

    # Check value parameter

    if type(value) is not str and value != None:
        try:
            value = value.name()
        except:
            debug_print("Invalid value parameter")
            return

    """
    Update combo box
    """

    debug_print("Updating combo box...")

    if value == None:
        combobox.setCurrentIndex(0)
    else:

        index = 0
        while index < combobox.count():
            item = combobox.itemText(index)

            if item == value:
                combobox.setCurrentIndex(index)
                break

            index += 1

    """
    Return success indicator
    """

    debug_print("Combo box successfully updated!")

    return True

def populateListView(listView, itemList):
    """
    ***************************************************************************
    Adds items from list to specified listView.

    PARAMETERS:
    * listView : list view | instance of QListView class
    * itemList : list of items | list of strings
    
    OUTPUTS:
    success indicator | boolean

    *************************************************************************** 
    """

    debug_print("Starting function populateListView.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check list view parameter

    if listView.__class__.__name__ != 'QListView':
        debug_print("Invalid list view parameter : not a list view")
        return

    # Check item list parameter

    if type(itemList) is not list:
        debug_print("Invalid item list parameter : not a list")
        return

    if len(itemList) < 1:
        debug_print("Invalid item list parameter : empty list")
        return

    for item in itemList:
        if type(item) is not str:
            debug_print("Invalid item list parameter : not a list of strings")
            return

    """
    Get list view model
    """

    debug_print("Getting list view model...")

    viewModel = listView.model()

    """
    Add items to list
    """

    debug_print("Adding items to list...")

    for item in itemList:

        valItem = QStandardItem(item)
        valItem.setCheckable(True)
        viewModel.appendRow(valItem)

    """
    Set list view model
    """

    debug_print("Setting list view model...")

    listView.setModel(viewModel)

    """
    Return success indicator
    """

    debug_print("List view successfully populated!")

    return True

def syncComboBoxes(comboBox, comboBoxes, value):
    """
    ***************************************************************************
    Updates related combo boxes to display given value.

    PARAMETERS:
    * comboBox : originating combo box | instance of QComboBox class
    * comboBoxes : list of combo boxes | list of instances of QComboBox class
    * value : common value | object
    
    OUTPUTS:
    success indicator | boolean

    *************************************************************************** 
    """

    debug_print("Starting function syncComboBoxes.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check combo box parameter

    if comboBox.__class__.__name__ != 'QComboBox':
        debug_print("Invalid combo box parameter : not a combo box")
        return

    # Check combo boxes parameter

    if type(comboBoxes) is not list:
        debug_print("Invalid combo boxes parameter : not a list")
        return

    for box in comboBoxes:
        if box.__class__.__name__ != 'QComboBox':
            debug_print("Invalid combo boxes parameter : not a list of combo boxes")
            return

    # Check value parameter

    if type(value) is not str and value != None:
        try:
            value = value.name()
        except:
            debug_print("Invalid value parameter")
            return

    """
    Update combo boxes
    """

    debug_print("Updating combo boxes...")

    for combo in comboBoxes:
        if combo != comboBox:
            if combo.currentText() != value:
                setComboBoxIndex(combo, value)
            else:
                break

    """
    Return success indicator
    """

    debug_print("Related combo boxes successfully synchronized!")

    return True

def syncListViews(listView, listViews, valueList):
    """
    ***************************************************************************
    Updates related list views to display given value list.

    PARAMETERS:
    * listView : originating list view | instance of QListView class
    * listViews : list of list views | list of instances of QListView class
    * valueList : list of common values | list
    
    OUTPUTS:
    success indicator | boolean

    *************************************************************************** 
    """

    debug_print("Starting function syncListViews.")

    """
    Check parameters
    """

    debug_print("Checking parameters...")

    # Check list view parameter

    if listView.__class__.__name__ != 'QListView':
        debug_print("Invalid combo box parameter : not a list view")
        return

    # Check list views parameter

    if type(listViews) is not list:
        debug_print("Invalid list views parameter : not a list")
        return

    for view in listViews:
        if view.__class__.__name__ != 'QListView':
            debug_print("Invalid list views parameter : not a list of list views")
            return

    # Check value list parameter

    if type(valueList) is not list:
        debug_print("Invalid list value parameter : not a list")
        return

    for value in valueList:
        if type(value) is not str and value != None:
            try:
                value = value.name()
            except:
                debug_print("Invalid list value parameter : contains invalid values")
                return

    """
    Update list views
    """

    debug_print("Updating list views...")

    for view in listViews:
        if view != listView:
            model = view.model()

            good = True

            i = 0
            while i < model.rowCount():
                if model.item(i).checkState == Qt.Checked:
                    if model.item(i).text() not in valueList:
                        good = False
                        break
                else:
                    if model.item(i).text() in valueList:
                        good = False
                        break
                i += 1

            if good:
                break

            i = 0
            while i < model.rowCount():
                if model.item(i).text() in valueList:
                    model.item(i).setCheckState(Qt.Checked)
                else:
                    model.item(i).setCheckState(Qt.Unchecked)
                i += 1

    """
    Return success indicator
    """

    debug_print("Related list views successfully synchronized!")

    return True

def debug_print(argument):
    if DEBUG_MODE:
        print(argument)

