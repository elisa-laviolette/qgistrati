# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QGIStratiDockWidget
                                 A QGIS plugin
 This plugin automates stratigraphic modelling tasks for archaeologists
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-05-04
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Elisa Caron-Laviolette
        email                : elisa.laviolette@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys

from PyQt5 import QtGui, QtWidgets, uic
from PyQt5.QtCore import pyqtSignal, pyqtProperty, Qt, QSize

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qgistrati_dockwidget_base.ui'))


class QGIStratiDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()
    openingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(QGIStratiDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def openEvent(self, event):
        self.openinPlugin.emit()
        event.accept()

"""
  Author: Jared P. Sutton <jpsutton@gmail.com>
  License: LGPL
  https://github.com/mojocorp/QProgressIndicator
    
"""

class QProgressIndicator (QtWidgets.QWidget):
  m_angle = None
  m_timerId = None
  m_delay = None
  m_displayedWhenStopped = None
  m_color = None

  def __init__ (self, parent):
    # Call parent class constructor first
    super(QProgressIndicator, self).__init__(parent)
    
    # Initialize Qt Properties
    self.setProperties()
    
    # Intialize instance variables
    self.m_angle = 0
    self.m_timerId = -1
    self.m_delay = 40
    self.m_displayedWhenStopped = False
    self.m_color = Qt.black
    
    # Set size and focus policy
    self.setSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    self.setFocusPolicy(Qt.NoFocus)
    
    # Show the widget
    self.show()
    
  def animationDelay (self):
    return self.delay
    
  def isAnimated (self):
    return (self.m_timerId != -1)
    
  def isDisplayedWhenStopped (self):
    return self.displayedWhenStopped
    
  def getColor (self):
    return self.color
    
  def sizeHint (self):
    return QSize(20, 20)
  
  def startAnimation (self):
    self.m_angle = 0
    
    if self.m_timerId == -1:
      self.m_timerId = self.startTimer(self.m_delay)
    
  def stopAnimation (self):
    if self.m_timerId != -1:
      self.killTimer(self.m_timerId)
      
    self.m_timerId = -1
    self.update()
    
  def setAnimationDelay (self, delay):
    if self.m_timerId != -1:
      self.killTimer(self.m_timerId)
      
    self.m_delay = delay
    
    if self.m_timerId != -1:
      self.m_timerId = self.startTimer(self.m_delay)
    
  def setDisplayedWhenStopped (self, state):
    self.displayedWhenStopped = state
    self.update()
    
  def setColor (self, color):
    self.m_color = color
    self.update()
    
  def timerEvent (self, event):
    self.m_angle = (self.m_angle + 30) % 360
    self.update()
    
  def paintEvent (self, event):
    if (not self.m_displayedWhenStopped) and (not self.isAnimated()):
      return

    width = min(self.width(), self.height())
    
    painter = QtGui.QPainter(self)
    painter.setRenderHint(QtGui.QPainter.Antialiasing)
    
    outerRadius = (width - 1) * 0.5
    innerRadius = (width - 1) * 0.5 * 0.38
    
    capsuleHeight = outerRadius - innerRadius
    capsuleWidth  = capsuleHeight *.23 if (width > 32) else capsuleHeight *.35
    capsuleRadius = capsuleWidth / 2
    
    for i in range(0, 12):
      color = QtGui.QColor(self.m_color)

      if self.isAnimated():
        color.setAlphaF(1.0 - (i / 12.0))
      else:
        color.setAlphaF(0.2)

      painter.setPen(Qt.NoPen)
      painter.setBrush(color)
      painter.save()
      painter.translate(self.rect().center())
      painter.rotate(self.m_angle - (i * 30.0))
      painter.drawRoundedRect(int(capsuleWidth * -0.5), int((innerRadius + capsuleHeight) * -1), int(capsuleWidth), int(capsuleHeight), capsuleRadius, capsuleRadius)
      painter.restore()
      
  def setProperties (self):
    self.delay = pyqtProperty(int, self.animationDelay, self.setAnimationDelay)
    self.displayedWhenStopped = pyqtProperty(bool, self.isDisplayedWhenStopped, self.setDisplayedWhenStopped)
    self.color = pyqtProperty(QtGui.QColor, self.getColor, self.setColor)

